"item_id","course_id","unit_nm","item_content","item_choices","item_answer","item_explain","item_type_cd","item_diff_cd","file_path","ins_user_type_cd","ins_user_id","ins_dt","upd_user_id","upd_dt","del_yn"
ITEM-506808-25b80d,"506808",cpp_02_기본입문,"﻿다음 코드의 실행 결과는?

#include <iostream>

namespace hallym {
    int year = 2025;
}
int year = 2024;

int main() {
    std::cout << hallym::year;
    return 0;
}","{""1"":""2024"",""2"":""2025"",""3"":""0"",""4"":""﻿컴파일 오류가 발생한다.""}","2","",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:15:37.218,N
ITEM-506808-f65a58,"506808",cpp_02_기본입문,"﻿아래 코드가 컴파일되지 않는 이유는?

﻿#include <iostream>
int main() {
    cout << ""Namespace test"";
    return 0;
}","{""1"":""﻿main 함수가 int를 반환할 수 없기 때문에"",""2"":""﻿cout이 std 이름 공간에 속해있어 std::cout으로 사용해야 하기 때문에"",""3"":""﻿문자열은 큰따옴표를 사용할 수 없기 때문에"",""4"":""﻿헤더 파일이 잘못되었기 때문에""}","2","",MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:14:13.917,N
ITEM-506808-7de1a9,"506808",cpp_02_기본입문,"﻿C++에서 std::cout << std::hex; 코드를 사용했을 때, 이어지는 정수 출력의 진법은?","{""1"":""﻿2진수"",""2"":""﻿8진수"",""3"":""﻿10진수"",""4"":""﻿16진수""}","4","",MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:22:14.331,N
ITEM-506808-6b3f31,"506808",cpp_02_기본입문,"﻿화면에 문자열 ""C++""과 함께 줄바꿈을 실행하는 코드로 올바른 것은?","{""1"":""﻿std::cin << \""C++\"" << std::endl;"",""2"":""﻿std::cout >> \""C++\"" >> std::endl;"",""3"":""﻿std::cout << \""C++\"" << std::endl;"",""4"":""﻿std::cin >> \""C++\"" >> std::endl;""}","3","",MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:10:44.338,N
ITEM-506808-206465,"506808",cpp_02_기본입문,﻿사용자로부터 너비(width)와 높이(height)를 한 줄에 입력 받아 각 변수에 저장하는 코드로 올바른 것은?,"{""1"":""﻿std::cin << width << height;"",""2"":""﻿std::cout >> width >> height;"",""3"":""﻿std::cin >> width >> height;"",""4"":""﻿std::cout << width << height;""}","3","",MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:17:07.112,N
ITEM-506808-7cc5af,"506808",cpp_02_기본입문,"﻿다음 bool 타입을 사용한 코드의 실행 결과는?

#include <iostream>
int main() {
    bool result = (5 > 3);
    std::cout << result;
    return 0;
}","{""1"":""0"",""2"":""1"",""3"":""true"",""4"":""false""}","2","(5 > 3)은 참(true)이며, bool 타입의 true는 cout으로 출력 시 기본적으로 정수 1로 변환됩니다.",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:18:24.694,N
ITEM-506808-8093f0,"506808",cpp_02_기본입문,"﻿다음 코드의 실행 결과는?

#include <iostream>
int main() {
    int a = 5;
    double b = 2.5;
    std::cout << a + b;
    return 0;
}","{""1"":""7"",""2"":""7.0"",""3"":""7.5"",""4"":""﻿컴파일 오류가 발생한다.""}","3",정수(int)와 실수(double)의 연산 시에는 표현 범위가 더 넓은 실수 타입으로 자동 형 변환되어 계산됩니다.,MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:19:53.727,N
ITEM-506808-965c3f,"506808",cpp_02_기본입문,"﻿enum class Day { SUN = 0, MON, TUE }; 와 같이 선언되었을 때, Day::MON의 정수 값은?","{""1"":""0"",""2"":""1"",""3"":""2"",""4"":""알 수 없다.""}","2","",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:24:55.930,N
ITEM-506808-2c585a,"506808",cpp_02_기본입문,"﻿다음 코드에서 오류가 발생하는 라인은?

enum class Color { Red, Blue };

int main() {
    Color c = Color::Red; 
    int num = 1;          
    if (c == Color::Blue) {} 
    if (c == num) {}         
    return 0;
}","{""1"":""﻿Color c = Color::Red;"",""2"":""int num = 1;"",""3"":""﻿if (c == Color::Blue) {}"",""4"":""﻿if (c == num) {}""}","4",enum class는 강력한 타입 검사를 하므로 다른 타입인 int형 변수와 직접 비교할 수 없습니다.,MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:26:40.092,N
ITEM-506808-55d126,"506808",cpp_02_기본입문,﻿다음 중 auto 키워드를 사용할 수 없어 컴파일 오류가 발생하는 경우는?,"{""1"":""﻿auto x = 100;"",""2"":""﻿for (auto c : \""hello\"") { }"",""3"":""﻿auto add(int a, int b) { return a + b; }"",""4"":""﻿void print(auto data);""}","4",auto는 함수의 매개변수 타입으로 사용할 수 없습니다.,MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:30:37.443,N
ITEM-506808-f13387,"506808",cpp_02_기본입문,"﻿포인터의 const 속성을 제거하기 위해 사용되는, 매우 신중하게 사용해야 할 캐스팅 연산자는?","{""1"":""﻿static_cast"",""2"":""﻿const_cast"",""3"":""﻿dynamic_cast"",""4"":""﻿reinterpret_cast""}","2","",MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:29:42.204,N
ITEM-506808-7c1196,"506808",cpp_02_기본입문,﻿변수를 const 키워드로 선언했을 때의 가장 핵심적인 역할은?,"{""1"":""﻿변수의 타입을 자동으로 추론해준다."",""2"":""﻿변수를 선언과 동시에 초기화할 수 게 만든다."",""3"":""﻿변수를 오직 정수형으로만 사용하게 강제한다."",""4"":""﻿변수를 상수처럼 만들어 값을 변경할 수 없게 한다.""}","4","",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:23:22.371,N
ITEM-506808-ef05c0,"506808",cpp_02_기본입문,"﻿다음 구조화된 바인딩 코드의 실행 결과는?

#include <iostream>
#include <string>

struct Book { std::string title; int price; };

int main() {
    Book b = {""C++"", 30000};
    auto [t, p] = b;
    std::cout << t;
    return 0;
}","{""1"":""C++"",""2"":""﻿30000"",""3"":""b"",""4"":""﻿컴파일 오류가 발생한다.""}","1","",MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:32:23.941,N
ITEM-506808-66f9ac,"506808",cpp_02_기본입문,﻿new 키워드를 사용하여 동적으로 할당된 메모리가 저장되는 공간은?,"{""1"":""﻿데이터(Data) 영역"",""2"":""﻿스택(Stack) 영역"",""3"":""﻿힙(Heap) 영역"",""4"":""﻿코드(Code) 영역""}","3",new 키워드로 할당하는 동적 메모리는 힙(Heap) 영역에 생성됩니다.,MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:33:13.938,N
ITEM-506808-7a04d3,"506808",cpp_02_기본입문,"﻿std::vector를 사용한 다음 코드의 실행 결과는?

#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec;
    vec.push_back(5);
    vec.push_back(10);
    std::cout << vec.size();
    return 0;
}","{""1"":""5"",""2"":""10"",""3"":""2"",""4"":""15""}","3","",MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:35:17.219,N
ITEM-506808-ccf567,"506808",cpp_02_기본입문,"﻿std::array를 사용한 다음 코드의 실행 결과는?

﻿#include <iostream>
#include <array>

int main() {
    std::array<int, 3> arr = {100, 200, 300};
    std::cout << arr[1];
    return 0;
}","{""1"":""100"",""2"":""200"",""3"":""300"",""4"":""1""}","2","",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:35:22.947,N
ITEM-506808-61b6dc,"506808",cpp_02_기본입문,"﻿C++ 표준 입출력(cout, cin)을 사용하기 위해 반드시 포함해야 하는 헤더 파일은?","{""1"":""﻿<string>"",""2"":""﻿<iostream>"",""3"":""﻿<stdio.h>"",""4"":""﻿<vector>""}","2","",MC,E,,LLM,"20994",2025-09-02 04:33:25.412,"21738",2025-09-02 14:46:27.463,N
ITEM-506808-6187ba,"506808",cpp_02_기본입문,"﻿std::vector<int> numbers가 있을 때, 이 벡터의 모든 요소를 순회하는 범위 기반 for문의 올바른 문법은?","{""1"":""﻿for (int num in numbers)"",""2"":""﻿for (int num : numbers)"",""3"":""﻿for (int num of numbers)"",""4"":""﻿for (numbers : int num)""}","2","",MC,M,,LLM,"20994",2025-09-02 05:05:40.773,"21738",2025-09-02 14:49:47.244,N
ITEM-506808-6a68a3,"506808",cpp_02_기본입문,"﻿다음 코드의 실행 결과는?

#include <iostream>
#include <initializer_list>

void printSum(std::initializer_list<int> list) {
    int sum = 0;
    for (int i : list) { sum += i; }
    std::cout << sum;
}

int main() {
    printSum({1, 2, 3});
    return 0;
}","{""1"":""123"",""2"":""3"",""3"":""6"",""4"":""﻿컴파일 오류가 발생한다.""}","3",{}로 묶인 값들의 합계를 계산하므로 1+2+3의 결과는 6입니다.,MC,H,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-02 14:37:17.856,N
ITEM-506808-39b147,"506808",cpp_03_문자열과참조,참조 변수의 참조 관계를 변경할 수 있나요?,"{""1"":""언제든지 변경 가능"",""2"":""한 번만 변경 가능"",""3"":""변경 불가능"",""4"":""컴파일러에 따라 다름""}","3",참조 변수는 초기화된 후에는 참조 관계를 변경할 수 없습니다. 이는 참조 변수의 특성상 하나의 대상만을 지속적으로 가리키기 때문입니다.,MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:34.619,Y
ITEM-506808-26eadb,"506808",cpp_03_문자열과참조,C++에서 문자열을 처리할 때 권장되는 클래스는 무엇인가요?,"{""1"":""char 배열"",""2"":""string 클래스"",""3"":""vector 클래스"",""4"":""array 클래스""}","2","C++에서는 string 클래스를 사용하여 문자열을 처리하는 것이 권장됩니다. 이는 문자열 크기에 따른 제약이 없고, 다양한 함수와 연산자를 통해 문자열을 쉽게 조작할 수 있기 때문입니다.",MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:26.093,Y
ITEM-506808-b62c4b,"506808",cpp_03_문자열과참조,C++에서 참조와 포인터의 차이점은 무엇인가요?,"{""1"":""참조는 항상 초기화해야 한다"",""2"":""포인터는 초기화할 필요가 없다"",""3"":""참조는 NULL 값을 가질 수 있다"",""4"":""포인터는 별칭 역할을 한다""}","1","참조는 선언 시 반드시 초기화되어야 하며, 이는 참조가 항상 유효한 대상을 가리키도록 보장하기 위한 것입니다.",MC,H,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:27.894,Y
ITEM-506808-eccd0f,"506808",cpp_03_문자열과참조,C++에서 string 객체를 복사할 때 사용하는 연산자는 무엇인가요?,"{""1"":""="",""2"":""*"",""3"":""&"",""4"":""+""}","1",string 객체는 '=' 연산자를 사용하여 복사할 수 있습니다. 이는 객체의 값을 다른 객체에 복사하는 역할을 합니다.,MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:29.758,Y
ITEM-506808-15ffa7,"506808",cpp_03_문자열과참조,C++에서 참조를 사용한 함수 호출의 장점은 무엇인가요?,"{""1"":""메모리 사용량 증가"",""2"":""값 복사 필요 없음"",""3"":""코드 가독성 감소"",""4"":""컴파일 시간 단축""}","2","참조를 사용한 함수 호출은 값 복사를 피할 수 있어, 메모리 사용량을 줄이고 성능을 향상시킬 수 있다는 장점이 있습니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:32.769,Y
ITEM-506808-4d1d88,"506808",cpp_03_문자열과참조,C++에서 산술 연산자가 아닌 것은?,"{""1"":""+"",""2"":""-"",""3"":""&&"",""4"":""*""}","3","&&는 논리 연산자입니다. 산술 연산자는 +, -, *, / 등이 있습니다.",MC,E,,LLM,"20994",2025-09-02 05:05:40.773,"20994",2025-09-03 13:05:16.696,Y
ITEM-506808-64abaa,"506808",cpp_03_문자열과참조,문자열을 입력받을 때 공백을 포함하여 읽을 수 있는 함수는 무엇인가요?,"{""1"":""cin"",""2"":""scanf"",""3"":""getline"",""4"":""fgets""}","3",getline 함수는 공백을 포함한 입력을 처리할 수 있는 함수입니다. 일반적인 cin은 공백을 기준으로 입력을 분할합니다.,MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:05:36.740,Y
ITEM-506808-f025db,"506808",cpp_03_문자열과참조,다음 중 C++에서 문자열의 끝을 나타내는 문자는 무엇인가요?,"{""1"":""\\0"",""2"":""\\n"",""3"":""\\t"",""4"":""\\b""}","1",C 스타일의 문자열은 '\0'로 끝나야 합니다. 이는 문자열의 끝을 나타내는 널(null) 문자입니다.,MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:06:47.979,Y
ITEM-506808-2781d7,"506808",cpp_03_문자열과참조,string 클래스 객체를 생성할 때 사용하는 헤더 파일은 무엇인가요?,"{""1"":""<iostream>"",""2"":""<vector>"",""3"":""<string>"",""4"":""<array>""}","3","string 클래스는 <string> 헤더 파일에 선언되어 있으며, 이 헤더 파일을 포함시켜야 string 클래스를 사용할 수 있습니다.",MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:17.780,Y
ITEM-506808-d6fa3c,"506808",cpp_03_문자열과참조,C++에서 참조 변수는 어떻게 선언하나요?,"{""1"":""int& ref;"",""2"":""int ref&;"",""3"":""int ref*;"",""4"":""int&* ref;""}","1","참조 변수는 자료형 뒤에 '&'를 붙여 선언합니다. 예를 들어, 'int& ref;'는 int형 참조 변수를 선언하는 방법입니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:13.054,Y
ITEM-506808-97538d,"506808",cpp_03_문자열과참조,C++에서 참조를 반환할 수 있는 함수의 예시는 무엇인가요?,"{""1"":""void 함수"",""2"":""int 함수"",""3"":""char& 함수"",""4"":""double* 함수""}","3","C++에서는 참조 타입을 반환할 수 있으며, 이는 'char& 함수'와 같이 선언합니다. 함수가 참조를 반환하면, 해당 참조는 함수 내에서 반환되는 변수의 메모리 공간을 가리킵니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:23.672,Y
ITEM-506808-8973eb,"506808",cpp_03_문자열과참조,C++에서 string 객체의 동적 생성을 위해 필요한 것은 무엇인가요?,"{""1"":""포인터"",""2"":""레퍼런스"",""3"":""new 연산자"",""4"":""delete 연산자""}","3",string 객체를 동적으로 생성하기 위해서는 new 연산자를 사용합니다. 이는 객체가 힙(heap)에 생성되어 생명 주기가 프로그램의 종료까지 유지되도록 합니다.,MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:28.436,Y
ITEM-506808-8f7b25,"506808",cpp_03_문자열과참조,getline() 함수는 C++에서 어떤 목적으로 사용되나요?,"{""1"":""정수 입력"",""2"":""문자열 입력"",""3"":""파일 읽기"",""4"":""파일 쓰기""}","2",getline() 함수는 문자열을 입력받기 위해 사용됩니다. 이는 공백을 포함한 문자열 입력을 처리할 수 있습니다.,MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:37.446,Y
ITEM-506808-3d822b,"506808",cpp_03_문자열과참조,string 클래스에서 제공되는 멤버 함수가 아닌 것은 무엇인가요?,"{""1"":""length()"",""2"":""append()"",""3"":""substr()"",""4"":""malloc()""}","4","malloc() 함수는 C 언어에서 동적 메모리를 할당하기 위해 사용되는 함수로, string 클래스의 멤버 함수가 아닙니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:42.173,Y
ITEM-506808-bd6167,"506808",cpp_03_문자열과참조,"참조 변수를 사용할 때, 새로운 메모리 공간이 할당되나요?","{""1"":""항상 할당된다"",""2"":""할당되지 않는다"",""3"":""조건부로 할당된다"",""4"":""컴파일러에 따라 다르다""}","2","참조 변수는 기존의 변수에 대한 별칭을 제공하며, 새로운 메모리 공간을 할당하지 않습니다. 참조 변수는 원본 변수의 메모리 공간을 공유합니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:07:48.609,Y
ITEM-506808-af11d3,"506808",cpp_03_문자열과참조,다음 중 C++에서 string 객체의 초기화를 올바르게 수행한 것은 무엇인가요?,"{""1"":""string name = 'Hallym';"",""2"":""string name = \""Hallym\"";"",""3"":""string name = Hallym;"",""4"":""string name = (Hallym);""}","2","string 객체는 큰따옴표("")를 사용하여 초기화해야 합니다. 작은따옴표('')는 문자 하나를 나타낼 때 사용됩니다.",MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:08:07.079,Y
ITEM-506808-13a4c3,"506808",cpp_03_문자열과참조,C++에서 참조 변수 선언 시 반드시 필요한 것은 무엇인가요?,"{""1"":""초기화"",""2"":""함수 호출"",""3"":""포인터"",""4"":""배열""}","1",참조 변수는 선언과 동시에 반드시 초기화해야 합니다. 초기화는 참조할 기존의 변수나 객체를 명시해주는 과정입니다.,MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:08:16.603,Y
ITEM-506808-2cdd13,"506808",cpp_03_문자열과참조,string_view 클래스는 어떤 버전의 C++에서 도입되었나요?,"{""1"":""C++98"",""2"":""C++03"",""3"":""C++11"",""4"":""C++17""}","4",string_view 클래스는 C++17에서 도입되었습니다. 이는 기존의 string과 달리 문자열의 부분을 가리키는 가벼운 객체로 사용됩니다.,MC,H,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:08:21.411,Y
ITEM-506808-22dcee,"506808",cpp_03_문자열과참조,C++에서 문자열의 크기에 제약이 없는 이유는 무엇인가요?,"{""1"":""컴파일러의 최적화"",""2"":""string 클래스의 내부 버퍼 조절 기능"",""3"":""메모리 관리 기법"",""4"":""포인터 사용""}","2","string 클래스는 문자열의 크기에 맞게 내부 버퍼를 자동으로 조절하는 기능이 있어, 문자열의 크기에 제약이 없습니다.",MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:08:25.347,Y
ITEM_506808_e8a9b4,"506808",cpp_03_문자열과참조,참조 변수 선언 시 자료형 뒤에 붙는 기호는 ( )이다.,"",&,"포인터는 int *p; 형태, 참조는 int &ref = 변수; 형태로 선언한다.",BLK,E,"",PROF,"21738",2025-09-29 17:20:29.589,,,N
ITEM-506808-0b7676,"506808",cpp_03_문자열과참조,C++에서 참조자는 어떤 기호를 사용하여 선언하나요?,"{""1"":""*"",""2"":""&"",""3"":""#"",""4"":""%""}","2","참조자는 '&' 기호를 사용하여 선언합니다. 이는 참조(reference)로, 기존 변수의 별칭을 만들어 줍니다.",MC,E,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:08:31.046,Y
ITEM-506808-078b94,"506808",cpp_03_문자열과참조,다음 중 string 객체의 크기를 반환하는 멤버 함수는 무엇인가요?,"{""1"":""size()"",""2"":""length()"",""3"":""capacity()"",""4"":""both size() and length()""}","4",string 클래스에서는 size()와 length() 모두 문자열의 크기를 반환하는 데 사용됩니다. 두 함수는 동일한 역할을 합니다.,MC,M,,LLM,"20994",2025-09-03 04:02:07.331,"20994",2025-09-03 13:06:41.150,Y
ITEM-506808-90cbff,"506808",cpp_03_문자열과참조,C++에서 문자열은 항상 null 문자로 끝나야 한다.,"",X,"C++의 string 클래스는 null 문자로 끝날 필요가 없으며, 문자열의 크기는 자체적으로 관리된다.",OX,E,,LLM,"21738",2025-09-29 08:13:18.364,,,N
ITEM-506808-5abfdf,"506808",cpp_03_문자열과참조,"참조 변수는 다른 변수의 별명으로, 초기화 이후 다른 변수를 참조할 수 없다.","",O,"참조 변수는 초기화 시 다른 변수를 참조하게 되며, 이후에는 참조 대상을 변경할 수 없다.",OX,M,,LLM,"21738",2025-09-29 08:13:18.364,,,N
ITEM-506808-5b6433,"506808",cpp_03_문자열과참조,C++에서 문자열을 연결할 때 + 연산자를 사용할 수 있다.,"",O,C++의 string 클래스는 + 연산자를 오버로딩하여 문자열을 쉽게 연결할 수 있게 해준다.,OX,E,,LLM,"21738",2025-09-29 08:13:18.364,,,N
ITEM-506808-266c71,"506808",cpp_03_문자열과참조,C++에서는 복사없는 문자열을 다루기 위해 string_view 클래스를 사용할 수 있다.,"",O,"string_view는 C++17부터 도입된 클래스로, 문자열을 복사하지 않고도 문자열을 처리할 수 있게 해준다.",OX,M,,LLM,"21738",2025-09-29 08:13:18.364,,,N
ITEM-506808-90e7f8,"506808",cpp_03_문자열과참조,C++에서는 C 스타일의 문자열을 사용할 때 <cstring> 라이브러리를 활용해야 한다.,"",O,C 스타일의 문자열은 <cstring> 라이브러리에 있는 함수를 사용하여 처리할 수 있다.,OX,E,,LLM,"21738",2025-09-29 08:13:18.364,,,N
ITEM_506808_4a02f0,"506808",cpp_03_문자열과참조,(     ) 변수는 이름만 생기고 새로운 공간은 할당되지 않는다.,"",참,참조는 원본 변수를 가리키는 또 다른 이름(alias)일 뿐이다. 별도의 메모리 공간을 만들지 않는다.,BLK,E,"",PROF,"21738",2025-09-29 17:20:29.589,,,N
ITEM_506808_612019,"506808",cpp_03_문자열과참조,참조 변수는 선언 시 반드시 (  )로 초기화해야 한다.,"",원본 변수,"참조 변수는 반드시 초기화가 필요하며, 이후 참조 대상을 변경할 수 없다.",BLK,E,"",PROF,"21738",2025-09-29 17:20:29.589,,,N
ITEM-506808-10a2f1,"506808",cpp_04_클래스와객체,"다음 Circle 객체 생성 코드 중, 함수의 원형으로 잘못 해석될 수 있는 코드는?\nclass Circle { public: Circle(){} };\n\n","{""1"":""Circle c1;"",""2"":""Circle c2 = Circle();"",""3"":""Circle c3{};"",""4"":""Circle c4()""}","4",`Circle c4();`는 “객체”가 아니라 “함수 선언”으로 파싱될 수 있는 유명한 모호성(가장 탐욕스러운 파싱) 사례입니다.,MC,M,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-6b3d90,"506808",cpp_04_클래스와객체,"class 키워드로 클래스를 정의할 때, 접근 지정자를 생략하면 멤버의 기본 접근 권한은?","{""1"":""public"",""2"":""private"",""3"":""protected"",""4"":""default""}","2","`class`는 기본이 private, `struct`는 기본이 public 입니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-9a2c5e,"506808",cpp_04_클래스와객체,다음 코드에서 컴파일 오류가 발생하는 라인은?\n\nclass MyClass {\n    int num;\npublic:\n    MyClass() { num = 0; }\n};\n\nint main() {\n    MyClass obj;\n    obj.num = 10;\n    return 0;\n}\n,"{""1"":""int num;"",""2"":""MyClass() { num = 0; }"",""3"":""MyClass obj;"",""4"":""obj.num = 10;""}","4",멤버 변수 num이 private이므로 클래스 외부인 main 함수에서 직접 접근할 수 없습니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-2e8f37,"506808",cpp_04_클래스와객체,클래스의 생성자(Constructor)에 대한 설명으로 올바른 것은?,"{""1"":""리턴 타입을 반드시 void 로 선언해야 한다"",""2"":""클래스 이름과 동일한 이름을 가져야 한다"",""3"":""매개변수를 가질 수 없다"",""4"":""프로그래머가 직접 호출해야 한다""}","2","생성자는 반환형을 쓰지 않으며, 클래스명과 동일해야 합니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-5f10b4,"506808",cpp_04_클래스와객체,다음 코드에서 컴파일 오류가 발생하는 이유는?\n\nclass Point {\npublic:\n    Point(int x) { /* ... */ }\n};\n\nint main() {\n    Point p;\n    return 0;\n}\n,"{""1"":""Point 클래스에 소멸자가 없기 때문에"",""2"":""매개변수가 있는 생성자가 선언되어, 컴파일러가 기본 생성자를 자동으로 만들지 않기 때문에"",""3"":""p 객체가 const 가 아니기 때문에"",""4"":""main 함수에서는 객체를 생성할 수 없기 때문에""}","2",사용자가 생성자를 하나라도 만들면 컴파일러는 매개변수 없는 기본 생성자를 자동으로 만들지 않습니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-7e2c91,"506808",cpp_04_클래스와객체,다음 코드의 실행 결과는?\n\nclass Mem {\n    int a = 10;\npublic:\n    void print() { cout << a; }\n};\n\nint main() {\n    Mem m;\n    m.print();\n    return 0;\n}\n,"{""1"":""0"",""2"":""10"",""3"":""알 수 없는 값"",""4"":""컴파일 오류가 발생한다""}","2",멤버 `a`는 10으로 초기화되어 `print()`가 10을 출력합니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-0c5db2,"506808",cpp_04_클래스와객체,"다음 코드의 실행 결과는?\n\nclass Point {\n    int x, y;\npublic:\n    Point() : x(10), y(20) {}\n    int getX() { return x; }\n};\n\nint main() {\n    Point p;\n    cout << p.getX();\n    return 0;\n}\n","{""1"":""0"",""2"":""10"",""3"":""20"",""4"":""컴파일 오류가 발생한다""}","2","생성자 초기화 리스트로 x=10, y=20이 설정됩니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-3a4e6f,"506808",cpp_04_클래스와객체,다음 중 클래스의 멤버 변수를 초기화하는 방법으로 틀린 것은?,"{""1"":""생성자 함수 몸체 안에서 대입"",""2"":""생성자 초기화 리스트 사용"",""3"":""클래스 선언부에서 직접 초기화"",""4"":""소멸자 안에서 대입""}","4",소멸자는 파괴 단계이므로 “초기화”와 무관합니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-4f9c12,"506808",cpp_04_클래스와객체,"다음 코드의 실행 결과는?\n\nclass Box {\n    int width;\npublic:\n    Box(int w) : width(w) { cout << ""W:"" << width; }\n    Box() : Box(10) { cout << "" D""; }\n};\n\nint main() {\n    Box b;\n    return 0;\n}\n","{""1"":""D"",""2"":""W:10"",""3"":""W:10 D"",""4"":""D W:10""}","3","기본 생성자가 먼저 `Box(10)` 생성자에게 생성을 위임하여 ""W:10""이 출력되고, 그 후에 기본 생성자의 몸체가 실행되어 "" D""가 출력됩니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-1de4a7,"506808",cpp_04_클래스와객체,Sample 클래스의 소멸자(Destructor)를 올바르게 선언한 것은?,"{""1"":""void ~Sample();"",""2"":""~Sample();"",""3"":""delete ~Sample();"",""4"":""~Sample(void);""}","2","소멸자는 반환형이 없고, 이름 앞에 `~`만 붙입니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-8b6a51,"506808",cpp_04_클래스와객체,"다음 코드의 실행 결과는? (생성/소멸 순서)\n\nclass Simple {\npublic:\n    Simple() { cout << ""C""; }\n    ~Simple() { cout << ""D""; }\n};\n\nint main() {\n    Simple s1;\n    Simple s2;\n    return 0;\n}\n","{""1"":""CDCD"",""2"":""CCDD"",""3"":""CCCD"",""4"":""CDDC""}","2","객체는 선언된 순서(s1, s2)대로 생성되고(C), 소멸(D)은 생성의 역순(s2, s1)으로 일어납니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-0f3c9e,"506808",cpp_04_클래스와객체,"다음 코드의 실행 결과는? (생성/소멸 순서)\n\nclass A {\npublic:\n    A() { cout << ""A""; }\n    ~A() { cout << ""~A""; }\n};\n\nclass B {\n    A member_a;\npublic:\n    B() { cout << ""B""; }\n    ~B() { cout << ""~B""; }\n};\n\nint main() {\n    B b;\n    return 0;\n}\n","{""1"":""BA~A~B"",""2"":""AB~A~B"",""3"":""AB~B~A"",""4"":""BA~B~A""}","3","멤버 객체(A)가 먼저 생성되고(`A`), 포함하는 객체(`B`)가 생성됩니다(`B`). 소멸은 생성의 역순입니다.",MC,M,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-2a0d64,"506808",cpp_04_클래스와객체,const 멤버 함수 내부에서 허용되지 않는 작업은?,"{""1"":""다른 const 멤버 함수를 호출하는 것"",""2"":""멤버 변수의 값을 읽는 것"",""3"":""멤버 변수의 값을 수정하는 것"",""4"":""지역 변수를 선언하고 사용하는 것""}","3",`const` 멤버 함수는 객체 상태를 변경하지 않아야 합니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-7c1b22,"506808",cpp_04_클래스와객체,"Circle 클래스 외부에 getArea() 멤버 함수를 구현하는 코드 중, 문법적으로 올바른 것은?\n\nclass Circle {\n    int radius;\npublic:\n    double getArea();\n};\n","{""1"":""Circle::double getArea() { return 3.14 * radius * radius; }"",""2"":""double Circle::getArea() { return 3.14 * radius * radius; }"",""3"":""double getArea() { return 3.14 * radius * radius; }"",""4"":""void getArea()::Circle { return 3.14 * radius * radius; }""}","2","반환형 → `double`, 범위 지정 → `Circle::getArea` 순서가 맞습니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-51e890,"506808",cpp_04_클래스와객체,`inline` 함수를 사용하는 주된 이유는?,"{""1"":""코드의 길이를 줄이기 위해"",""2"":""함수 호출에 따른 오버헤드를 줄여 실행 속도를 향상시키기 위해"",""3"":""메모리 사용량을 줄이기 위해"",""4"":""컴파일 시간을 단축시키기 위해""}","2",인라이닝은 호출 오버헤드 줄이기가 목적입니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-9f6d31,"506808",cpp_04_클래스와객체,멤버 함수가 자동으로 inline 으로 처리되는 경우는?,"{""1"":""함수가 private 영역에 선언되었을 때"",""2"":""함수가 생성자일 때"",""3"":""클래스 선언부 내부에 함수 구현이 정의되었을 때"",""4"":""함수가 const 멤버 함수일 때""}","3",클래스 정의 내부 구현은 인라인 제안으로 간주됩니다(필수는 아님).,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-3b7a6d,"506808",cpp_04_클래스와객체,"다음 struct를 사용한 코드에 대한 설명으로 올바른 것은?\n\nstruct Point {\n    int x, y;\n};\n\nint main() {\n    Point p;\n    p.x = 10;\n    return 0;\n}\n","{""1"":""x, y 가 private 이므로 p.x = 10;에서 오류가 발생한다"",""2"":""struct 는 생성자가 없으므로 Point p;에서 오류가 발생한다"",""3"":""x, y 의 기본 접근 지정이 public 이므로 정상적으로 컴파일된다"",""4"":""struct 는 C++에서 사용할 수 없으므로 오류가 발생한다""}","3",struct의 멤버는 기본적으로 public 접근 권한을 갖습니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-8e0f44,"506808",cpp_04_클래스와객체,`MyClass.cpp` 파일에서 사용자가 직접 만든 `MyClass.h` 헤더 파일을 포함(include)하는 올바른 코드는?,"{""1"":""#include <MyClass.cpp>"",""2"":""#include \""MyClass.cpp\"""",""3"":""#include <MyClass.h>"",""4"":""#include \""MyClass.h\""""}","4","사용자가 직접 만든 헤더 파일은 보통 큰따옴표("""")를 사용하여 포함합니다.",MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-2d9c70,"506808",cpp_04_클래스와객체,"헤더 파일 상단에 `#ifndef`, `#define`, `#endif`를 사용하는 주된 이유는?","{""1"":""파일의 버전을 표시하기 위해"",""2"":""헤더 파일이 중복으로 포함(include)되는 것을 방지하기 위해"",""3"":""특정 운영체제에서만 코드가 컴파일되도록 하기 위해"",""4"":""클래스 멤버를 private 으로 만들기 위해""}","2",전형적인 include guard 패턴입니다.,MC,E,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-6a1b55,"506808",cpp_04_클래스와객체,다음 코드에서 컴파일 오류가 발생하는 가장 정확한 이유는?\n\nclass Test {\n    int val;\npublic:\n    void regularFunc() { val = 1; }\n    void constFunc() const {\n        regularFunc(); // 오류 발생 지점\n    }\n};\n,"{""1"":""const 멤버 함수는 다른 멤버 함수를 호출할 수 없기 때문에"",""2"":""const 멤버 함수는 멤버 변수 val 에 접근할 수 없기 때문에"",""3"":""const 멤버 함수는 const 가 아닌 멤버 함수를 호출할 수 없기 때문에"",""4"":""regularFunc 함수가 public 이 아니기 때문에""}","3",const가 아닌 멤버 함수는 멤버 변수를 수정할 가능성이 있으므로 const 멤버 함수 내에서 호출이 금지됩니다.,MC,M,cpp_04_클래스와객체_quiz_sol.pdf,MANU,adm,2025-09-29 17:37:44.203,,,N
ITEM-506808-7d2f0a,"506808",cpp_05_객체포인터와동적생성,"Circle 클래스의 객체 포인터 p 가 객체 donut 을 가리킬 때, 멤버 함수 getArea()를 호출하는 올바른 방법은?","{""1"":""p.getArea()"",""2"":""p->getArea()"",""3"":""p::getArea()"",""4"":""p.getArea()->""}","2",객체 포인터는 `->`로 멤버에 접근합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-3c8e50,"506808",cpp_05_객체포인터와동적생성,"Circle c[3];와 같이 객체 배열을 선언할 때, 배열의 각 원소 객체를 초기화하기 위해 호출되는 생성자는?","{""1"":""항상 매개변수가 있는 생성자"",""2"":""프로그래머가 명시적으로 지정한 생성자"",""3"":""매개변수가 없는 디폴트 생성자"",""4"":""복사 생성자""}","3",기본 생성자가 호출되어 각 원소가 초기화됩니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-0b7c6a,"506808",cpp_05_객체포인터와동적생성,"다음 코드의 실행 결과는?\n\nclass Simple {\npublic:\n    Simple() { cout << ""C""; }\n    ~Simple() { cout << ""D""; }\n};\n\nint main() {\n    Simple arr[2];\n    return 0;\n}\n","{""1"":""CDCD"",""2"":""CCDD"",""3"":""DDCC"",""4"":""CDDC""}","2","객체는 선언된 순서대로 생성되고(C), 소멸은 생성의 역순으로 일어납니다(D).",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-5a0f2c,"506808",cpp_05_객체포인터와동적생성,다음 클래스 타입의 객체 배열 초기화 코드 중 문법적으로 올바른 것은?\n\nclass Circle {\npublic:\n    Circle(){}\n    Circle(int r){}\n};\n,"{""1"":""Circle arr = {10, 20};"",""2"":""Circle arr[2] = {Circle(10), Circle(20)};"",""3"":""Circle arr[2](10, 20);"",""4"":""Circle arr[2] = (10, 20);""}","2",중괄호 목록 초기화로 각 원소에 적절한 생성자를 적용합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-2c9b71,"506808",cpp_05_객체포인터와동적생성,new 연산자를 사용하여 int 타입의 메모리를 동적으로 할당하는 올바른 코드는?,"{""1"":""int p = new int;"",""2"":""int* p = new int;"",""3"":""int& p = new int;"",""4"":""int* p = new int[2];""}","2",단일 `int`는 `int* p = new int;`가 정답입니다(배열은 별개).,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-6d3e15,"506808",cpp_05_객체포인터와동적생성,new 연산자를 이용한 동적 할당에 대한 설명으로 틀린 것은?,"{""1"":""컴파일 시간이 아닌 실행 시간에 메모리가 할당된다"",""2"":""malloc()과 달리 생성자를 자동으로 호출해준다"",""3"":""할당된 메모리는 힙(heap) 영역에 위치한다"",""4"":""할당된 메모리는 자동으로 해제된다""}","4",new로 할당된 메모리는 반드시 delete로 직접 해제해야 합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-9e1f44,"506808",cpp_05_객체포인터와동적생성,new 로 생성한 객체 포인터를 delete 할 때 일어나는 일로 올바른 것은?,"{""1"":""객체의 생성자가 호출된 후 메모리가 해제된다"",""2"":""객체의 소멸자가 호출된 후 메모리가 해제된다"",""3"":""메모리가 먼저 해제된 후 객체의 소멸자가 호출된다"",""4"":""메모리만 해제되고 소멸자는 호출되지 않는다""}","2",소멸자가 먼저 실행되고 메모리가 반납됩니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-1a7d60,"506808",cpp_05_객체포인터와동적생성,int* p = new int[5]; 코드로 동적으로 할당된 배열 메모리를 올바르게 해제하는 코드는?,"{""1"":""delete p;"",""2"":""delete p[5];"",""3"":""delete[] p;"",""4"":""free(p);""}","3",배열에는 `delete[]`를 사용해야 소멸자가 올바르게 호출됩니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-0d6a2e,"506808",cpp_05_객체포인터와동적생성,"다음 코드의 실행 결과는?\n\nclass Test {\n    int id;\npublic:\n    Test(int i) : id(i) { cout << ""C"" << id; }\n    ~Test() { cout << ""D"" << id; }\n};\n\nint main() {\n    Test* arr = new Test[2]{ Test(1), Test(2) };\n    delete[] arr;\n    return 0;\n}\n","{""1"":""C1C2D1D2"",""2"":""C1C2D2D1"",""3"":""C2C1D1D2"",""4"":""C2C1D2D1""}","2",배열의 소멸자는 생성 순서의 역순으로 호출됩니다.,MC,M,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-2f5b0c,"506808",cpp_05_객체포인터와동적생성,다음 중 delete 사용 시 런타임 오류가 발생할 가능성이 가장 높은 코드는?,"{""1"":""int* p = new int; delete p; p = nullptr;"",""2"":""int* p = new int[5]; delete[] p;"",""3"":""int n; int* p = &n; delete p;"",""4"":""int* p = new int; delete p; int* q = new int; delete q;""}","3",new로 할당하지 않은 스택 메모리를 delete하려고 시도하면 런타임 오류가 발생합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-4b2e1a,"506808",cpp_05_객체포인터와동적생성,"다음 코드의 실행 결과는?\n\nclass Dog {\n    string* name;\npublic:\n    Dog(string s) { name = new string(s); }\n    ~Dog() { delete name; }\n    string getName() { return *name; }\n};\n\nint main() {\n    Dog d(""Bori"");\n    cout << d.getName();\n    return 0;\n}\n","{""1"":""Bori"",""2"":""Bori 의 주소값"",""3"":""컴파일 오류"",""4"":""아무것도 출력되지 않는다""}","1","생성자에서 new를 통해 name 멤버를 동적 할당하고, 소멸자에서 delete로 해제하는 올바른 코드입니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-9c1d80,"506808",cpp_05_객체포인터와동적생성,다음 코드에서 메모리 누수(memory leak)가 발생하는 라인은?\n\nint main() {\n    char* p = new char[100];\n    char c = 'a';\n    p = &c;\n    delete[] p;\n    return 0;\n}\n,"{""1"":""char* p = new char[100];"",""2"":""char c = 'a';"",""3"":""p = &c;"",""4"":""delete[] p;""}","3",원래 p가 가리키던 동적 할당 메모리의 주소를 잃어버려 메모리 누수가 발생합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-1c0f72,"506808",cpp_05_객체포인터와동적생성,delete p; 실행 후 p = nullptr; 코드를 추가하는 주된 이유는?,"{""1"":""메모리 해제를 수행하기 위해"",""2"":""댕글링 포인터(dangling pointer)가 되는 것을 방지하기 위해"",""3"":""프로그램 실행 속도를 높이기 위해"",""4"":""포인터 변수 p 를 즉시 소멸시키기 위해""}","2","delete 후에도 p는 여전히 해제된 메모리 주소를 가리키고 있으므로, 이를 nullptr로 초기화하여 실수를 방지합니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-3e7b66,"506808",cpp_05_객체포인터와동적생성,this 포인터에 대한 설명으로 틀린 것은?,"{""1"":""객체 자기 자신을 가리키는 포인터이다"",""2"":""멤버 함수 내에서만 사용할 수 있다"",""3"":""개발자가 직접 선언하고 초기화해야 한다"",""4"":""멤버 변수와 매개변수의 이름이 같을 때 유용하다""}","3",`this`는 컴파일러가 암묵적으로 제공합니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-7a0d39,"506808",cpp_05_객체포인터와동적생성,다음 코드의 실행 결과는?\n\nclass Data {\npublic:\n    int val;\n};\n\nint main() {\n    Data arr[3];\n    arr[0].val = 10;\n\n    Data* p = arr;\n    (p + 1)->val = 20;\n\n    cout << arr[1].val;\n    return 0;\n}\n,"{""1"":""10"",""2"":""20"",""3"":""0"",""4"":""컴파일 오류""}","2","포인터 p는 배열 arr의 시작 주소를 가리키고, (p + 1)은 두 번째 원소(arr[1])를 가리킵니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-0a6c5e,"506808",cpp_05_객체포인터와동적생성,"다음 Person 클래스 코드의 가장 큰 문제점은?\n\nclass Person {\n    string* pName;\npublic:\n    Person(string name) {\n        pName = new string(name);\n        cout << *pName << "" 객체 생성"" << endl;\n    }\n    ~Person() {\n        cout << *pName << "" 객체 소멸 시도"" << endl;\n    }\n};\n\nint main() {\n    Person p(""Kim"");\n    return 0;\n}\n","{""1"":""생성자에서 new 를 사용하여 멤버 변수를 초기화할 수 없다."",""2"":""소멸자에서 delete 를 사용하여 생성자에서 할당된 pName 메모리를 해제하지 않아 메모리 누수(memory leak)가 발생한다."",""3"":""포인터 멤버 변수는 private 일 수 없다."",""4"":""main 함수에서 Person 객체를 new 로 생성하지 않았다.""}","2",소멸자에서 delete를 사용하여 생성자에서 할당된 pName 메모리를 해제하지 않아 메모리 누수(memory leak)가 발생한다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-4d3e10,"506808",cpp_05_객체포인터와동적생성,다음 중 this 포인터를 사용할 수 없는 함수는?,"{""1"":""public 멤버 함수"",""2"":""private 멤버 함수"",""3"":""static 멤버 함수"",""4"":""const 멤버 함수""}","3","static 멤버 함수는 특정 객체에 속하지 않으므로, 객체 자신을 가리키는 this 포인터가 존재하지 않습니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-2b8f61,"506808",cpp_05_객체포인터와동적생성,다음 코드에서 this 포인터를 반드시 사용해야 하는 이유는?\n\nclass Power {\n    int charge;\npublic:\n    Power(int charge) {\n        this->charge = charge;\n    }\n};\n,"{""1"":""멤버 변수 charge 가 private 이어서"",""2"":""생성자의 매개변수 이름과 멤버 변수 이름이 같아서"",""3"":""charge 가 포인터 변수여서"",""4"":""생성자가 public 이어서""}","2","this->charge는 멤버 변수를, charge는 매개변수를 명확히 구분해줍니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-6f1c2a,"506808",cpp_05_객체포인터와동적생성,unique_ptr 스마트 포인터의 가장 핵심적인 특징은?,"{""1"":""여러 포인터가 하나의 객체를 동시에 소유할 수 있다"",""2"":""참조 카운트(reference count)를 통해 객체를 관리한다"",""3"":""하나의 객체는 단 하나의 unique_ptr 만이 소유할 수 있다"",""4"":""new[]로 할당된 배열은 관리할 수 없다""}","3",단독 소유가 보장되는 스마트 포인터입니다.,MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-0e9b63,"506808",cpp_05_객체포인터와동적생성,"다음 코드의 실행 결과, sp1의 참조 카운트(use_count())는 최종적으로 얼마인가?\n\nint main() {\n    auto sp1 = make_shared<int>(10);\n    auto sp2 = sp1;\n    auto sp3 = sp1;\n    cout << sp1.use_count();\n    return 0;\n}\n","{""1"":""0"",""2"":""1"",""3"":""2"",""4"":""3""}","4","sp1이 생성될 때 참조 카운트는 1이 되고, sp2와 sp3가 sp1을 복사하면서 참조 카운트가 2, 3으로 순차적으로 증가합니다.",MC,E,cpp_05_객체포인터와동적생성_quiz_sol.pdf,MANU,adm,2025-09-29 17:38:03.090,,,N
ITEM-506808-4b71e9,"506808",cpp_06_복사이동생성자,std::move 함수의 역할은?,"{""1"":""L-value를 R-value처럼 보이게 만들어 이동을 가능하게 한다"",""2"":""메모리 블록을 물리적으로 다른 위치로 이동시킨다"",""3"":""객체를 복사한 후 원본을 삭제한다"",""4"":""R-value를 L-value로 변환한다""}","1","std::move는 객체를 강제로 R-value로 캐스팅하여, 이동 생성자나 이동 대입 연산자가 호출되도록 유도합니다.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-0f3a9c,"506808",cpp_06_복사이동생성자,"함수에 객체를 값으로 전달(call-by-value)할 때, 매개변수 객체에서 일어나는 일로 올바른 것은?\n\nvoid func(Circle c) { /* ... */ }\n\nint main() {\n    Circle waffle(10);\n    func(waffle);\n    return 0;\n}\n","{""1"":""c 의 생성자가 호출된다"",""2"":""waffle 의 내용이 c 로 복사되며, c 의 생성자는 호출되지 않는다"",""3"":""waffle 의 주소가 c 에 전달된다"",""4"":""함수가 종료되어도 c 의 소멸자는 호출되지 않는다""}","2","값 전달 시 매개변수 c는 복사 생성으로 초기화되고(복사된 내용 보유), 함수가 끝나면 c의 소멸자가 호출됩니다. 생성자는 새 객체를 만들 때 호출되므로 “c의 생성자 호출”은 아님.",MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-6c92df,"506808",cpp_06_복사이동생성자,"다음 코드의 실행 결과는?\n\nclass Test {\n    int val;\npublic:\n    Test(int n) : val(n) { cout << ""C:"" << val << "" ""; }\n    ~Test() { cout << ""D:"" << val << "" ""; }\n    void set(int n) { val = n; }\n};\n\nvoid func(Test t) {\n    t.set(20);\n}\n\nint main() {\n    Test t1(10);\n    func(t1);\n    return 0;\n}\n","{""1"":""C:10 D:10"",""2"":""C:10 D:20"",""3"":""C:10 C:20 D:20 D:10"",""4"":""C:10 D:20 D:10""}","4","t1 생성 시 ""C:10""이 출력됩니다. func(t1) 호출 시 t1 이 복사되어 매개변수 t 가 생성되며, t.set(20)으로 t 의 값이 20 으로 바뀝니다. func 종료 시 t 가 소멸하며 ""D:20""이 출력되고, main 함수 종료 시 t1 이 소멸하며 ""D:10""이 출력됩니다.",MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-b7e534,"506808",cpp_06_복사이동생성자,"함수 호출 시 객체의 복사 비용을 없애고, 함수 내에서 원본 객체를 직접 수정하고자 할 때 가장 적절한 매개변수 전달 방식은?","{""1"":""void func(Circle c)"",""2"":""void func(Circle* p)"",""3"":""void func(Circle& c)"",""4"":""void func(const Circle& c)""}","3",원본 수정 + 복사 회피면 비-const 참조가 적합. 포인터도 가능하지만 참조가 더 직관적이며 널 위험이 없음. const 참조는 수정 불가.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-4ac6df,"506808",cpp_06_복사이동생성자,다음 코드의 실행 결과는?\n\nclass Data {\npublic:\n    int val;\n};\n\nint main() {\n    Data d1;\n    d1.val = 10;\n    Data d2;\n    d2.val = 20;\n\n    d1 = d2;\n    d2.val = 30;\n    cout << d1.val;\n\n    return 0;\n}\n,"{""1"":""10"",""2"":""20"",""3"":""30"",""4"":""컴파일 오류""}","2", d1 = d2; 시점에 d2 의 값(20)이 d1 으로 복사됩니다. 이후 d2 의 값을 30 으로 바꾸더라도 이미 복사된 d1 의 값에는 영향을 주지 않습니다.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-2d8f6a,"506808",cpp_06_복사이동생성자,얕은 복사(shallow copy) 시에 문제가 발생할 수 있는 가장 대표적인 경우는?,"{""1"":""클래스에 멤버 변수가 없는 경우"",""2"":""기본 타입의 멤버만 있는 경우"",""3"":""포인터 멤버가 동적 메모리를 가리키는 경우"",""4"":""const 멤버 변수가 있는 경우""}","3",포인터만 복사하면 동일 메모리를 두 객체가 공유하여 이중 해제 등 심각한 문제를 유발. 이때 깊은 복사 필수.,MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-99e0a4,"506808",cpp_06_복사이동생성자,깊은 복사(deep copy)에 대한 설명으로 올바른 것은?,"{""1"":""객체의 주소만 복사한다"",""2"":""복사본과 원본이 메모리를 공유한다"",""3"":""포인터가 가리키는 데이터 자체를 별도 공간에 복제한다"",""4"":""std::string이 있으면 깊은 복사는 불가능하다""}","3",깊은 복사는 동적 리소스의 “소유 데이터”까지 새로 할당/복제하여 소유권 충돌을 방지.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-3f51bc,"506808",cpp_06_복사이동생성자,복사 생성자의 올바른 선언 형태는? (MyClass 기준),"{""1"":""MyClass(MyClass c);"",""2"":""MyClass(MyClass& c);"",""3"":""MyClass(MyClass* p);"",""4"":""void MyClass(MyClass& c);""}","2",복사 생성자는 보통 `MyClass(const MyClass& other)` 형태. (const는 권장),MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-8d9c1e,"506808",cpp_06_복사이동생성자,"다음 코드의 실행 결과는?\n\nclass Test {\n    int val;\npublic:\n    Test(int n) : val(n) { cout << ""C ""; }\n    Test(const Test& other) : val(other.val) { cout << ""CC ""; }\n};\n\nint main() {\n    Test t1(10);\n    Test t2 = t1;\n    return 0;\n}\n","{""1"":""C"",""2"":""C C"",""3"":""C CC"",""4"":""CC""}","3","Test t1(10);에서 일반 생성자가 호출되어 ""C""가 출력되고, Test t2 = t1;에서 t1 을 복사하여 t2 를 초기화하므로 복사 생성자가 호출되어 ""CC""가 출력됩니다.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-5a9c0d,"506808",cpp_06_복사이동생성자,생성자 앞에 explicit 키워드를 붙였을 때의 효과는?,"{""1"":""생성자가 private으로 변경된다"",""2"":""해당 생성자를 통해서만 객체 생성이 가능해진다"",""3"":""묵시적 형 변환이 발생하는 것을 막는다"",""4"":""생성자가 자동으로 inline 처리된다""}","3",`explicit`은 단일 인자 생성자 등의 암묵적 변환을 차단해 의도치 않은 변환을 방지.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-c9de74,"506808",cpp_06_복사이동생성자,디폴트 복사 생성자가 수행하는 작업은?,"{""1"":""모든 멤버를 0으로 초기화한다"",""2"":""멤버 변수들을 얕은 복사(shallow copy)한다"",""3"":""멤버 변수들을 깊은 복사(deep copy)한다"",""4"":""아무 작업도 수행하지 않는다""}","2",컴파일러가 만드는 기본 복사 생성자는 멤버별 얕은 복사를 수행.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-f9a93e,"506808",cpp_06_복사이동생성자,"다음 코드에서 얕은 복사로 인해 발생하는 가장 큰 문제점은?\n\nclass Person {\n    char* name;\npublic:\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n    ~Person() { delete[] name; }\n};\n\nint main() {\n    Person p1(""Kim"");\n    Person p2 = p1;\n    return 0;\n}\n","{""1"":""p1의 이름이 p2로 완전히 이동한다"",""2"":""p1과 p2가 소멸될 때, 동일한 메모리를 두 번 해제하려고 시도한다"",""3"":""p2의 name이 초기화되지 않는다"",""4"":""new로 할당한 메모리가 너무 작다""}","2",얕은 복사로 포인터 값만 공유 → 소멸 시 이중 delete 문제가 발생.,MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-7e9c1a,"506808",cpp_06_복사이동생성자,다음 중 복사 생성자가 호출되지 않는 경우는?,"{""1"":""Person p2 = p1;"",""2"":""func(p1); (void func(Person p) 형태의 함수에 객체를 값으로 전달할 때)"",""3"":""Person* p2 = &p1;"",""4"":""Person p2(p1);""}","3",포인터는 객체를 만들지 않으므로 복사 생성자 호출이 발생하지 않음.,MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-b2d9f9,"506808",cpp_06_복사이동생성자,"다음 코드의 실행 결과는?\n\nclass Simple {\npublic:\n    Simple() { cout << ""C ""; }\n    Simple(const Simple& other) { cout << ""CC ""; }\n};\n\nSimple func(Simple s) {\n    return s;\n}\n\nint main() {\n    Simple obj;\n    func(obj);\n    return 0;\n}\n","{""1"":""C CC"",""2"":""C CC CC"",""3"":""C C C"",""4"":""CC CC""}","2","Simple obj;에서 기본 생성자(""C"")가 호출됩니다. func(obj) 호출 시, obj 가 매개변수 s 로 복사되면서 복사 생성자(""CC"")가 호출됩니다. func 함수가 s 를 반환할 때, 임시 객체가 생성되면서 다시 복사 생성자(""CC"")가 호출됩니다.",MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-1a9d9b,"506808",cpp_06_복사이동생성자,L-value 와 R-value 에 대한 설명으로 올바른 것은?,"{""1"":""L-value는 이름과 주소를 가지며, R-value는 임시적인 값이다"",""2"":""L-value는 리터럴 상수이며, R-value는 변수이다"",""3"":""int n = 10;에서 n은 R-value, 10은 L-value이다"",""4"":""모든 L-value는 R-value가 될 수 없다""}","1","L-value는 식별 가능한 저장 위치를 지니고, R-value는 일시적 결과값을 의미.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-5c3f9e,"506808",cpp_06_복사이동생성자,R-value 참조를 선언하는 올바른 문법은?,"{""1"":""int& ref = 10;"",""2"":""int&& ref = 10;"",""3"":""const int& ref = 10;"",""4"":""int* ref = &10;""}","2","R-value 참조는 `&&` 문법을 사용하며, 임시값(리터럴 등)에 바인딩 가능.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-0d8e91,"506808",cpp_06_복사이동생성자,이동 생성자(move constructor)에 대한 설명으로 올바른 것은?,"{""1"":""const 객체를 복사하기 위해 사용된다"",""2"":""R-value 참조를 인자로 받아, 원본 객체의 리소스를 훔쳐오는 방식으로 동작한다"",""3"":""복사 생성자보다 항상 실행 속도가 느리다"",""4"":""모든 클래스에 컴파일러가 자동으로 생성해준다""}","2",이동 생성자는 불필요한 복사를 피하고 리소스 소유권을 효율적으로 이전합니다.,MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-93a0c9,"506808",cpp_06_복사이동생성자,"다음 코드의 실행 결과는?\n\nvoid func(string& s) { cout << ""L-value""; }\nvoid func(string&& s) { cout << ""R-value""; }\nint main() {\n    string str = ""hello"";\n    func(str);\n    return 0;\n}\n","{""1"":""L-value"",""2"":""R-value"",""3"":""컴파일 오류"",""4"":""아무것도 출력되지 않는다""}","1","변수 str은 이름과 주소를 가진 L-value이므로, string&를 인자로 받는 함수 오버로드가 호출됩니다.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-2a6fd9,"506808",cpp_06_복사이동생성자,"다음 코드의 실행 결과는?\n\nvoid func(string& s) { cout << ""L-value""; }\nvoid func(string&& s) { cout << ""R-value""; }\nint main() {\n    func(""hello"");\n    return 0;\n}","{""1"":""L-value"",""2"":""R-value"",""3"":""컴파일 오류"",""4"":""아무것도 출력되지 않는다""}","2","문자열 리터럴 ""hello""는 임시 객체인 R-value이므로, string&&를 인자로 받는 함수 오버로드가 호출됩니다.",MC,E,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-d4e8b9,"506808",cpp_06_복사이동생성자,"다음 코드 실행 시 마지막에 출력되는 내용은 무엇인가요?\n\n#include <iostream>\n#include <string>\n#include <utility>\nusing namespace std;\nclass DataHolder {\n    string* pData;\npublic:\n    DataHolder(string data) { pData = new string(data); }\n    DataHolder(DataHolder&& other) noexcept {\n        pData = other.pData; other.pData = nullptr;\n    }\n    ~DataHolder() { delete pData; }\n    void print() {\n        if (pData) { cout << *pData; } else { cout << ""null""; }\n    }\n};\nint main() {\n    DataHolder d1(""MyData"");\n    DataHolder d2 = move(d1);\n    cout << ""d1:""; d1.print();\n    cout << "" d2:""; d2.print();\n    return 0;\n}","{""1"":""d1:MyData d2:MyData"",""2"":""d1:null d2:MyData"",""3"":""d1:MyData d2:null"",""4"":""컴파일 오류가 발생한다""}","2","std::move(d1)에 의해 d1이 R-value로 취급되어 이동 생성자가 호출됩니다. 이 과정에서 d2는 d1의 자원(데이터 포인터)을 가져오고, d1의 포인터는 nullptr이 되므로 최종적으로 ""d1:null d2:MyData""가 출력됩니다.",MC,M,cpp_06_복사이동생성자_quiz_sol.pdf,MANU,adm,2025-09-29 17:42:47.663,,,N
ITEM-506808-9d4c2e,"506808",cpp_07_함수중복과static멤버,"다음 코드의 실행 결과는?\n\nclass Calc {\npublic:\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n};\n\nint main() {\n    Calc c;\n    cout << c.add(3, 4) << c.add(3.5, 4.5);\n    return 0;\n}\n","{""1"":""77"",""2"":""78"",""3"":""7.08.0"",""4"":""컴파일 오류가 발생한다""}","2","c.add(3, 4)는 int 버전을 호출하여 7을, c.add(3.5, 4.5)는 double 버전을 호출하여 8.0을 출력합니다. cout은 공백 없이 이어 붙여 출력합니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-91def4,"506808",cpp_07_함수중복과static멤버,"다음 코드의 실행 결과는?\n\nclass A {\n    int val;\npublic:\n    A(int n) : val(n) {}\n    A(int n, int m) : val(n + m) {}\n    void print() { cout << val; }\n};\n\nint main() {\n    A a(10, 20);\n    a.print();\n    return 0;\n}\n","{""1"":""10"",""2"":""20"",""3"":""30"",""4"":""컴파일 오류가 발생한다""}","3","오버로딩된 생성자 중 (int,int) 생성자가 호출되어 10+20=30.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-f9a94e,"506808",cpp_07_함수중복과static멤버,다음 중 생성자 함수를 중복(overloading)하는 가장 주된 이유는?,"{""1"":""객체의 소멸 시점을 다양하게 하기 위해"",""2"":""객체를 생성할 때 다양한 방법으로 멤버 변수를 초기화하기 위해"",""3"":""멤버 함수의 개수를 줄이기 위해"",""4"":""클래스의 메모리 크기를 줄이기 위해""}","2",다양한 초기화 요구를 충족하기 위해 매개변수 구성을 달리합니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9d7f9a,"506808",cpp_07_함수중복과static멤버,"다음 코드의 실행 결과는?\n\nvoid print(string s, int n = 1) {\n    for (int i = 0; i < n; i++) cout << s;\n}\n\nint main() {\n    print(""Go"");\n    print(""Hi"", 2);\n    return 0;\n}\n","{""1"":""GoHiHi"",""2"":""Go GoHi"",""3"":""GoHi"",""4"":""컴파일 오류가 발생한다""}","1","첫 호출은 ""Go""(1회), 둘째는 ""Hi""(2회) → “GoHiHi”.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9f59bc,"506808",cpp_07_함수중복과static멤버,다음 중 디폴트 매개변수 선언으로 컴파일 오류가 발생하는 것은?,"{""1"":""void func(int a, int b = 10);"",
  ""2"":""void func(int a = 5, int b = 10);"",
  ""3"":""void func(int a = 5, int b);"",
  ""4"":""void func(string s = \""a\"", int b = 10);""}","3",디폴트 매개변수는 항상 일반 매개변수보다 뒤쪽(오른쪽)에 위치해야 합니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9a8c0d,"506808",cpp_07_함수중복과static멤버,다음 두 함수를 디폴트 매개변수를 사용하여 하나의 함수로 올바르게 합친 것은?\n\nvoid draw() { /* 10 개의 '*' 출력 */ }\nvoid draw(int n) { /* n 개의 '*' 출력 */ },"{""1"":""void draw(int n = 10) { /* n 개의 '*' 출력 */ }"",""2"":""void draw(int& n) { /* n 개의 '*' 출력 */ }"",""3"":""void draw(int n) { /* n 개의 '*' 출력 */ }"",""4"":""void draw(const int n) { /* 10 개의 '*' 출력 */ }""}","1","draw() 호출 시 n은 10이 되고, draw(5) 호출 시 n은 5가 되어 두 경우 모두를 처리할 수 있습니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-94e7a4,"506808",cpp_07_함수중복과static멤버,"다음 코드에서 `myFunc(10);` 호출 시 컴파일 오류가 발생하는 이유는?\n\nvoid myFunc(int a) { cout << ""1""; }\nvoid myFunc(int a, int b = 5) { cout << ""2""; }\n\nint main() {\n    myFunc(10);\n    return 0;\n}\n","{""1"":""myFunc 함수가 private 이어서"",""2"":""myFunc(10) 호출이 모호하기 때문에"",""3"":""int 타입은 디폴트 매개변수를 가질 수 없기 때문에"",""4"":""함수 중복은 3 개 이상이어야 하기 때문에""}","2","컴파일러는 myFunc(10)을 호출해야 할지, myFunc(10, 5)로 해석해야 할지 구분할 수 없습니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-b9e531,"506808",cpp_07_함수중복과static멤버,다음 코드에서 `square(3)` 호출 시 컴파일 오류가 발생하는 이유는?\n\nfloat square(float a) { return a*a; }\ndouble square(double a) { return a*a; }\n\nint main() {\n    square(3);\n    return 0;\n}\n,"{""1"":""정수 3 을 float 으로 변환할지 double 로 변환할지 모호하기 때문에"",""2"":""square 라는 이름의 함수가 중복되었기 때문에"",""3"":""main 함수에서는 부동소수점 연산을 할 수 없기 때문에"",""4"":""리턴 타입이 다르기 때문에""}","1",정수 3을 float으로 변환할지 double로 변환할지 모호하기 때문에. 컴파일러는 어떤 타입으로 자동 형 변환을 해야 최적인지 판단할 수 없습니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9ac0df,"506808",cpp_07_함수중복과static멤버,non-static 멤버 변수에 대한 설명으로 올바른 것은?,"{""1"":""클래스당 하나만 생성되며 모든 객체가 공유한다"",""2"":""객체가 생성될 때마다 객체 내부에 별도로 생성된다"",""3"":""프로그램 시작 시 생성되어 종료 시 소멸된다"",""4"":""클래스 이름을 통해 직접 접근할 수 있다""}","2",non-static 멤버는 인스턴스별로 별도 저장됩니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-07a9b2,"506808",cpp_07_함수중복과static멤버,다음 중 함수 중복(overloading)이 성공하는 조건으로 올바른 것은?,"{""1"":""함수의 이름이 같고, 리턴 타입이 다르다"",""2"":""함수의 이름이 같고, 매개변수의 개수나 타입이 다르다"",""3"":""함수의 이름은 다르지만, 기능이 동일하다"",""4"":""함수의 리턴 타입과 매개변수 개수가 모두 동일하다""}","2",오버로딩은 시그니처(매개변수 개수/타입)가 달라야 성립합니다. 반환형만 다른 것은 불가.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9d7c70,"506808",cpp_07_함수중복과static멤버,static 멤버 변수에 대한 설명으로 올바른 것은?,"{""1"":""객체가 생성될 때마다 객체 내부에 별도로 생성된다"",""2"":""프로그램 시작 시 생성되며, 동일한 클래스의 모든 객체가 공유한다"",""3"":""static 멤버 함수 내에서는 접근할 수 없다"",""4"":""반드시 생성자 초기화 리스트를 통해서만 초기화해야 한다""}","2",정적 수명/공유 특성을 지니며 클래스 외부에 정의가 필요합니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9d2e71,"506808",cpp_07_함수중복과static멤버,다음 코드에서 컴파일 오류를 수정하기 위한 올바른 코드는?\n\nclass Test {\npublic:\n    static int value;\n};\n\nint main() {\n    Test::value = 100;\n    return 0;\n}\n,"{""1"":""int Test::value; 를 main 함수 밖에 추가한다"",""2"":""static int value; 를 public: 아래에 쓴다"",""3"":""Test t; t.value = 100; 으로 수정한다"",""4"":""class Test 를 struct Test 로 바꾼다""}","1",static 멤버 변수는 클래스 외부의 전역 공간에 별도의 정의 및 초기화가 필요합니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9c8f0e,"506808",cpp_07_함수중복과static멤버,다음 코드의 실행 결과는?\n\nclass Counter {\npublic:\n    static int count;\n    Counter() { count++; }\n};\n\nint Counter::count = 0;\n\nint main() {\n    Counter c1;\n    Counter c2;\n    cout << Counter::count;\n    return 0;\n}\n,"{""1"":""0"",""2"":""1"",""3"":""2"",""4"":""컴파일 오류가 발생한다""}","3","Counter 객체 c1, c2가 생성될 때마다 생성자 내부에서 static 변수인 count가 1씩 증가하여 최종적으로 2가 됩니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9c92de,"506808",cpp_07_함수중복과static멤버,"다음 코드에서 컴파일 오류가 발생하는 이유는?\n\nint add(int a, int b) { return a + b; }\ndouble add(int x, int y) { return (double)(x + y); }\n\nint main() {\n    add(3, 4);\n    return 0;\n}\n","{""1"":""add 라는 이름의 함수를 두 번 선언할 수 없기 때문에"",""2"":""main 함수에서 add 함수를 호출할 수 없기 때문에"",""3"":""리턴 타입만 다른 경우 함수 중복이 성립하지 않기 때문에"",""4"":""정수와 실수는 동시에 사용할 수 없기 때문에""}","3",반환형만 바꾼 오버로딩은 허용되지 않습니다. 매개변수 목록이 달라야 합니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9a4d3b,"506808",cpp_07_함수중복과static멤버,static 멤버 함수에 대한 설명으로 틀린 것은?,"{""1"":""객체가 생성되기 전에도 호출할 수 있다"",""2"":""non-static 멤버 변수에 직접 접근할 수 있다"",""3"":""동일한 클래스의 다른 static 멤버에는 접근할 수 있다"",""4"":""this 포인터를 사용할 수 없다""}","2","static 멤버 함수는 객체가 존재하지 않아도 호출될 수 있으므로, 특정 객체에 속한 non-static 멤버에는 접근할 수 없습니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-9ea9c2,"506808",cpp_07_함수중복과static멤버,다음 코드에서 컴파일 오류가 발생하는 이유는?\n\nclass Sample {\n    int non_static_val;\npublic:\n    static void print() {\n        cout << non_static_val;\n    }\n};\n,"{""1"":""print 함수가 public 이 아니어서"",""2"":""non_static_val 이 초기화되지 않아서"",""3"":""static 멤버 함수는 non-static 멤버 변수에 접근할 수 없기 때문에"",""4"":""static 멤버 함수는 cout 을 사용할 수 없기 때문에""}","3",static 함수 내부에서는 인스턴스 멤버(비정적)에 접근할 수 없습니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-d4e3b9,"506808",cpp_07_함수중복과static멤버,"다음 코드의 실행 결과는?\n\nclass Person {\npublic:\n    static int shared;\n    int personal;\n    Person(int p) : personal(p) {}\n    void add() {\n        shared += 10;\n        personal += 5;\n    }\n};\n\nint Person::shared = 100;\n\nint main() {\n    Person p1(10);\n    Person p2(20);\n    p1.add();\n    p2.add();\n    cout << p1.personal << "","" << Person::shared;\n    return 0;\n}\n","{""1"":""15,110"",""2"":""15,120"",""3"":""25,110"",""4"":""25,120""}","2",personal은 각 객체에 속한 변수이므로 p1.personal은 10+5=15가 됩니다. shared는 모든 객체가 공유하는 변수이므로 100+10+10=120이 됩니다.,MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-5a6f9c,"506808",cpp_07_함수중복과static멤버,다음 중 static 멤버를 호출하는 올바른 방법이 아닌 것은?\n\nclass Math {\npublic:\n    static int abs(int a) { return a > 0 ? a : -a; }\n};\n\nint main() {\n    // ...\n}\n,"{""1"":""Math::abs(-5);"",""2"":""Math m; m.abs(-5);"",""3"":""Math* p = new Math(); p->abs(-5);"",""4"":""abs(-5);""}","4","abs 함수는 Math 클래스에 속한 static 멤버이므로, Math::abs(-5)와 같이 클래스 이름을 통해 접근해야 합니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-3e8b96,"506808",cpp_07_함수중복과static멤버,다음 코드의 실행 결과는?\n\nclass Circle {\npublic:\n    static int numOfCircles;\n    Circle() { numOfCircles++; }\n    ~Circle() { numOfCircles--; }\n};\n\nint Circle::numOfCircles = 0;\n\nint main() {\n    Circle c1;\n    Circle* p = new Circle[2];\n    delete[] p;\n    cout << Circle::numOfCircles;\n    return 0;\n}\n,"{""1"":""0"",""2"":""1"",""3"":""2"",""4"":""3""}","2","c1 생성 시 1, new Circle[2]로 2개가 더 생성되어 총 3이 되었다가, delete[] p로 2개가 소멸되어 최종적으로 1이 남습니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-19a2f9,"506808",cpp_07_함수중복과static멤버,"다음 코드에서 `obj2.SimpleFunc();` 호출 시 실행되는 출력 결과는?\n\nclass SoSimple {\n    int num;\npublic:\n    SoSimple(int n) : num(n) {}\n    void SimpleFunc() { cout << ""SimpleFunc""; }\n    void SimpleFunc() const { cout << ""const SimpleFunc""; }\n};\n\nint main() {\n    SoSimple obj1(3);\n    const SoSimple obj2(7);\n    obj1.SimpleFunc();\n    cout << "", "";\n    obj2.SimpleFunc();\n    return 0;\n}\n","{""1"":""SimpleFunc, SimpleFunc"",""2"":""SimpleFunc, const SimpleFunc"",""3"":""const SimpleFunc, const SimpleFunc"",""4"":""const SimpleFunc, SimpleFunc""}","2","const로 선언된 객체(obj2)가 멤버 함수를 호출하면, 오버로딩된 함수 중 const 버전이 우선적으로 선택됩니다. 일반 객체(obj1)는 non-const 버전을 호출합니다.",MC,E,cpp_07_함수중복과static멤버_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:08.925,,,N
ITEM-506808-38b5c6,"506808",cpp_08_프렌드와연산자중복,자기 자신에 대한 대입(a = a;)을 안전하게 처리하기 위해 operator= 내부에 추가하는 코드는?,"{""1"":""if (this == &rhs) return *this;"",""2"":""if (this != &rhs) return *this;"",""3"":""if (*this == rhs) return *this;"",""4"":""if (this->equals(rhs)) return *this;""}","1","this는 객체 자신을 가리키는 포인터이므로, 인자로 들어온 rhs의 주소와 비교하여 자기 자신에 대한 대입인지 확인할 수 있습니다.",MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-20b3c4,"506808",cpp_08_프렌드와연산자중복,클래스에 friend 로 선언된 함수에 대한 올바른 설명은?,"{""1"":""클래스의 멤버 함수로 취급된다"",""2"":""해당 클래스의 private 멤버에 접근할 수 없다"",""3"":""클래스 외부 함수지만, 해당 클래스의 private 멤버에 접근할 수 있다"",""4"":""friend 함수는 반드시 static 으로 선언되어야 한다""}","3",friend는 비멤버지만 접근 권한을 부여받습니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-21c4d5,"506808",cpp_08_프렌드와연산자중복,다음 코드에서 컴파일 오류가 발생하는 이유는?\n\nclass Point {\n    int x;\npublic:\n    Point(int val) : x(val) {}\n};\n\nvoid printX(Point p) {\n    cout << p.x;\n}\n,"{""1"":""printX 함수가 Point 객체를 값으로 받기 때문에"",""2"":""printX 함수가 Point 클래스에 friend 로 선언되지 않았기 때문에"",""3"":""Point 클래스에 생성자가 없기 때문에"",""4"":""printX 함수는 bool 타입을 반환해야 하기 때문에""}","2",private 멤버 x에 접근하려면 friend 선언이 필요합니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-22d5e6,"506808",cpp_08_프렌드와연산자중복,Manager 클래스의 멤버 함수를 Data 클래스의 friend 로 선언하는 올바른 문법은?,"{""1"":""friend bool Manager::isEqual(Data d);"",""2"":""friend bool isEqual(Data d);"",""3"":""friend Manager::isEqual(Data d);"",""4"":""friend bool Data::isEqual(Manager m);""}","1",멤버 함수를 프렌드로 지정: 반환형과 클래스범위 지정 포함.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-23e6f7,"506808",cpp_08_프렌드와연산자중복,Manager 클래스 전체를 Data 클래스의 friend 로 만드는 올바른 문법은?,"{""1"":""friend all Manager;"",""2"":""friend Manager::*;"",""3"":""friend class Manager;"",""4"":""friend void Manager();""}","3",friend 뒤에 class 키워드와 클래스 이름을 명시하면 해당 클래스 전체를 프렌드로 선언할 수 있습니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-24f708,"506808",cpp_08_프렌드와연산자중복,다음 코드의 실행 결과는?\n\nclass Data {\n    int val;\npublic:\n    Data(int v) : val(v) {}\n    friend void showVal(Data d);\n};\n\nvoid showVal(Data d) {\n    cout << d.val;\n}\n\nint main() {\n    Data d(100);\n    showVal(d);\n    return 0;\n}\n,"{""1"":""100"",""2"":""0"",""3"":""알 수 없는 값"",""4"":""컴파일 오류가 발생한다""}","1",friend 함수는 private 멤버 val에 접근할 수 있습니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-25a819,"506808",cpp_08_프렌드와연산자중복,연산자 중복(operator overloading)에 대한 설명으로 틀린 것은?,"{""1"":""C++에 원래 있던 연산자만 중복할 수 있다"",""2"":""연산자의 우선순위나 피연산자의 개수를 바꿀 수 있다"",""3"":""클래스 객체를 기본 타입처럼 다룰 수 있게 해준다"",""4"":""연산자는 함수 형태로 구현된다""}","2",우선순위/결합성은 변경할 수 없습니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-26b92a,"506808",cpp_08_프렌드와연산자중복,다음 중 C++에서 중복(overloading)할 수 없는 연산자는?,"{""1"":""+ (덧셈 연산자)"",""2"":""== (비교 연산자)"",""3"":"":: (범위 지정 연산자)"",""4"":""++ (증감 연산자)""}","3",범위 지정 연산자(::)는 오버로딩 불가 목록입니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-27ca3b,"506808",cpp_08_프렌드와연산자중복,a + b 가 a.operator+(b) 로 해석될 때 operator+는 어떻게 구현된 것인가?,"{""1"":""전역 함수로 구현되었다"",""2"":""클래스의 멤버 함수로 구현되었다"",""3"":""friend 함수로 구현되었다"",""4"":""static 멤버 함수로 구현되었다""}","2",a + b와 같은 연산자 표현식은 컴파일러에 의해 왼쪽 피연산자(a)의 멤버 함수인 operator+를 호출하는 형태로 변환됩니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-28db4c,"506808",cpp_08_프렌드와연산자중복,"다음 Power 클래스에 operator+를 멤버 함수로 구현한 코드의 실행 결과는?\n\nclass Power {\n    int kick;\npublic:\n    Power(int k=0) : kick(k) {}\n    Power operator+(const Power& op2) {\n        return Power(this->kick + op2.kick);\n    }\n    void print() { cout << kick; }\n};\n\nint main() {\n    Power a(10), b(20), c;\n    c = a + b;\n    c.print();\n    return 0;\n}\n","{""1"":""10"",""2"":""20"",""3"":""30"",""4"":""컴파일 오류가 발생한다""}","3",두 kick의 합 30을 가진 임시로 초기화됩니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-29ec5d,"506808",cpp_08_프렌드와연산자중복,"다음 코드의 실행 결과는?\n\nclass Power {\n    int kick;\npublic:\n    Power(int k=0) : kick(k) {}\n    bool operator==(const Power& op2) {\n        return this->kick == op2.kick;\n    }\n};\n\nint main() {\n    Power a(10), b(20), c(10);\n    cout << (a == b) << (a == c);\n    return 0;\n}\n","{""1"":""00"",""2"":""01"",""3"":""10"",""4"":""11""}","2","첫 비교는 false(0), 두 번째는 true(1) → “01”.",MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-30fd6e,"506808",cpp_08_프렌드와연산자중복,"다음 코드의 실행 결과는?\n\nclass Power {\n    int kick;\npublic:\n    Power(int k=0) : kick(k) {}\n    Power& operator+=(const Power& op2) {\n        this->kick += op2.kick;\n        return *this;\n    }\n    void print() { cout << kick; }\n};\n\nint main() {\n    Power a(10), b(20);\n    a += b;\n    a.print();\n    return 0;\n}\n","{""1"":""10"",""2"":""20"",""3"":""30"",""4"":""컴파일 오류가 발생한다""}","3",누적 덧셈 후 30을 출력합니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-31ae7f,"506808",cpp_08_프렌드와연산자중복,"전위 증가 연산자(++a)를 멤버 함수로 중복할 때, 올바른 함수 원형은?","{""1"":""Power operator++();"",""2"":""Power& operator++();"",""3"":""Power operator++(int x);"",""4"":""Power& operator++(int x);""}","2",전위 증가는 객체 자신을 변경한 후 그 참조를 반환하여 int b = ++a;와 같은 연쇄적인 연산을 가능하게 하는 것이 일반적입니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-32bf80,"506808",cpp_08_프렌드와연산자중복,"후위 증가 연산자(a++)를 멤버 함수로 중복할 때, 전위와 구분하기 위한 매개변수는?","{""1"":""const 키워드"",""2"":""아무것도 없는 빈 괄호 ()"",""3"":""int 타입의 더미(dummy) 변수"",""4"":""참조(&) 기호""}","3",후위는 dummy int 매개변수로 전위와 구분합니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-33c091,"506808",cpp_08_프렌드와연산자중복,b = 2 + a; 를 가능하게 하려면 operator+를 어떻게 구현해야 하는가? (a는 Power 객체),"{""1"":""Power 클래스의 멤버 함수로 구현한다"",""2"":""Power 클래스와 무관한 전역 함수로만 구현한다"",""3"":""전역 함수로 구현하고 Power 클래스에 friend 로 선언한다"",""4"":""Power 클래스의 static 멤버 함수로 구현한다""}","3","2 + a는 2.operator+(a)로 해석될 수 없으므로 멤버 함수로 구현이 불가능합니다. 따라서 전역 함수로 구현하고, private 멤버에 접근해야 할 경우 friend로 선언해야 합니다.",MC,M,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-34d1a2,"506808",cpp_08_프렌드와연산자중복,"다음 코드의 실행 결과는?\n\nclass Power {\n    int kick;\npublic:\n    Power(int k=0) : kick(k) {}\n    void print() { cout << kick; }\n    friend Power operator+(int val, const Power& op);\n};\n\nPower operator+(int val, const Power& op) {\n    return Power(val + op.kick);\n}\n\nint main() {\n    Power a(10), b;\n    b = 20 + a;\n    b.print();\n    return 0;\n}\n","{""1"":""10"",""2"":""20"",""3"":""30"",""4"":""컴파일 오류가 발생한다""}","3",전역 연산자를 통해 20+10=30.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-35e2b3,"506808",cpp_08_프렌드와연산자중복,"스트림 삽입 연산자 << 중복 시, `cout << a << b;` 연쇄 출력을 위해 리턴 타입은?","{""1"":""ostream"",""2"":""ostream*"",""3"":""ostream&"",""4"":""void""}","3",cout << a의 결과가 다시 cout 객체 자신의 참조가 되어야 (cout << a) << b; 와 같은 연쇄적인 출력이 가능해집니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-36f3c4,"506808",cpp_08_프렌드와연산자중복,"다음 코드의 실행 결과는?\n\nclass Power {\n    int kick;\npublic:\n    Power(int k=0) : kick(k) {}\n    friend ostream& operator<<(ostream& out, const Power& p);\n};\n\nostream& operator<<(ostream& out, const Power& p) {\n    out << p.kick;\n    return out;\n}\n\nint main() {\n    Power a(100);\n    cout << a;\n    return 0;\n}\n","{""1"":""100"",""2"":""0"",""3"":""Power"",""4"":""컴파일 오류가 발생한다""}","1",연산자<<가 내부에서 kick을 출력합니다.,MC,E,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-37a4b5,"506808",cpp_08_프렌드와연산자중복,"다음 코드에서 p1 = createPerson(); 라인이 호출하는 연산자는?\n\nclass Person {\npublic:\n    Person(int id=0, const char* name=\""\""){};\n    Person& operator=(const Person& rhs) { cout << \""C\""; return *this; }\n    Person& operator=(Person&& rhs) noexcept { cout << \""M\""; return *this; }\n};\n\nPerson createPerson() {\n    return Person(10, \""Hallym\"");\n}\n\nint main() {\n    Person p1(1, \""software\"");\n    p1 = createPerson();\n    return 0;\n}\n","{""1"":""복사 생성자"",""2"":""복사 대입 연산자"",""3"":""이동 생성자"",""4"":""이동 대입 연산자""}","4","createObject()가 반환하는 값은 사라지기 직전의 임시 객체(R-value)입니다. 이미 생성된 객체 p1에 R-value를 대입하므로, operator=(Person&&) 형태의 이동 대입 연산자가 호출됩니다.",MC,M,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-39c6d7,"506808",cpp_08_프렌드와연산자중복,"다음 operator= 구현에는 치명적인 결함이 있습니다. p1 = p1;과 같이 자기 자신에게 객체를 대입할 때 발생할 수 있는 가장 심각한 문제는 무엇인가요?\n\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nclass Person {\n    char* name;\npublic:\n    Person(const char* n) {\n        name = new char[strlen(n) + 1];\n        strcpy(name, n);\n    }\n\n    ~Person() { delete[] name; }\n\n    Person& operator=(const Person& rhs) {\n          delete[] name; \n          name = new char[strlen(rhs.name) + 1]; \n          strcpy(name, rhs.name); \n        \n          return *this;\n    }\n};\n\nint main() {\n    Person p1(\""Kim\"");\n    p1 = p1; \n\n    return 0;\n}\n","{""1"":""아무 문제 없이 정상적으로 실행된다."",""2"":""name 이 두 번 해제되어 프로그램이 종료된다."",""3"":""name 을 delete 한 후, 이미 해제된 rhs.name 에 접근하여 미정의 동작이 발생한다."",""4"":""new 로 메모리 할당 시 항상 실패한다.""}","3","자기 자신에게 대입할 때(p1 = p1), this와 &rhs는 같은 객체를 가리킵니다. 따라서 delete[] name;으로 자신의 메모리를 해제한 직후, strlen(rhs.name)에서 이미 해제된 메모리에 접근하려다 치명적인 오류가 발생합니다.",MC,M,cpp_08_프렌드와연산자중복_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:26.922,,,N
ITEM-506808-d3e4f5,"506808",cpp_09_상속,"다음 코드의 실행 결과는? (소멸자 호출 순서)

class Base { public: ~Base() { cout << ""B ""; } };

class Derived : public Base { public: ~Derived() { cout << ""D ""; } };

int main() {
    Derived d;
    return 0;
}

","{""1"": ""D B"", ""2"": ""B D"", ""3"": ""B"", ""4"": ""D""}","1",소멸은 생성의 역순입니다. **파생 소멸자 → 기본 소멸자** 순서이므로 `D B`가 출력됩니다.,MC,H,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-c0d1e2,"506808",cpp_09_상속,다이아몬드 상속 구조에서 최상위 기본 클래스의 멤버가 중복 상속되는 문제를 해결하기 위한 키워드는?,"{""1"": ""static"", ""2"": ""friend"", ""3"": ""virtual"", ""4"": ""override""}","3",가상 상속(`virtual`)을 사용하면 최상위 기본 클래스 서브오브젝트가 하나만 유지됩니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-a91f2b,"506808",cpp_09_상속,기본 클래스 Person 을 public 으로 상속받는 Student 클래스를 올바르게 선언한 것은?,"{""1"": ""class Student extends Person {}"", ""2"": ""class Student : public Person {}"", ""3"": ""class Person : public Student {}"", ""4"": ""class Student inherits Person {}""}","2",C++의 공용 상속 표기는 `class Derived : public Base {}` 입니다. 자바의 `extends`가 아니라 콜론(:)과 접근지정자를 사용합니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-b7d3e4,"506808",cpp_09_상속,"다음 코드에 대한 설명으로 올바른 것은?

class Point {
public:
    void set(int x, int y);
};

class ColorPoint : public Point {
public:
    void setColor(string color);
};

int main() {
    ColorPoint cp;
    cp.set(10, 20);
    return 0;
}
","{""1"": ""cp 는 Point 클래스의 멤버에 접근할 수 없어 컴파일 오류가 발생한다"", ""2"": ""파생 클래스의 객체는 기본 클래스의 public 멤버를 사용할 수 있다"", ""3"": ""Point 클래스가 ColorPoint 를 상속받아야 한다"", ""4"": ""set 함수는 ColorPoint 클래스에만 존재한다""}","2",파생 클래스의 객체는 기본 클래스의 public 멤버를 사용할 수 있다. ColorPoint 객체 cp는 Point로부터 public 멤버인 set() 함수를 물려받았기 때문에 직접 호출할 수 있습니다.,MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-c4f8a0,"506808",cpp_09_상속,파생 클래스의 포인터를 기본 클래스의 포인터로 타입 변환하는 것을 무엇이라고 하는가?,"{""1"": ""다운 캐스팅 (down-casting)"", ""2"": ""업 캐스팅 (up-casting)"", ""3"": ""강제 캐스팅 (force-casting)"", ""4"": ""동적 캐스팅 (dynamic-casting)""}","2",파생→기본으로 올리는 방향이라 '업캐스팅'이라고 부릅니다. 안전하고 자주 쓰입니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-d1e2f3,"506808",cpp_09_상속,"다음 코드의 실행 결과로 가장 가능성이 높은 것은?

class Point {};

class ColorPoint : public Point {};

int main() {
    Point p;
    ColorPoint* cp = (ColorPoint*)&p;
    // cp를 통해 ColorPoint의 멤버에 접근 시도
    return 0;
}

}","{""1"": ""항상 안전하게 동작한다"", ""2"": ""컴파일 오류가 발생한다"", ""3"": ""p 가 실제로는 Point 객체이므로, cp 를 사용하면 미정의 동작을 유발할 수 있다"", ""4"": ""업 캐스팅이 먼저 수행되어야 한다""}","3","Point 객체는 ColorPoint가 아니므로, 강제로 다운 캐스팅하여 ColorPoint의 멤버에 접근하려고 하면 메모리 구조가 달라 예기치 않은 오류가 발생할 수 있습니다.",MC,H,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-e6a7b8,"506808",cpp_09_상속,"기본 클래스의 멤버 x 를 파생 클래스에서는 접근 가능하지만, 외부에서는 접근할 수 없도록 하는 접근 지정자는?","{""1"": ""public"", ""2"": ""private"", ""3"": ""protected"", ""4"": ""friend""}","3",`protected`는 파생 클래스 내부에서는 접근 가능하지만 클래스 외부에서는 접근할 수 없도록 합니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-f0c9d2,"506808",cpp_09_상속,"다음 코드에서 컴파일 오류가 발생하는 라인은?

class Base {
protected:
    int num;
};

class Derived : public Base {
public:
    void set(int n) { num = n; }
};

int main() {
    Derived d;
    d.num = 100;
    return 0;
}

","{""1"": ""int num;"", ""2"": ""void set(int n) { num = n; }"", ""3"": ""Derived d;"", ""4"": ""d.num = 100;""}","4","num은 Base 클래스의 protected 멤버이므로, 파생 클래스인 Derived의 멤버 함수 내에서는 접근할 수 있지만, main 함수와 같은 외부에서는 직접 접근할 수 없습니다.",MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-a2b3c4,"506808",cpp_09_상속,"class Derived : private Base 와 같이 private 상속을 했을 때, Base 클래스의 public 멤버는 Derived 클래스에서 어떤 접근 권한을 갖게 되는가?","{""1"": ""public"", ""2"": ""protected"", ""3"": ""private"", ""4"": ""접근할 수 없다""}","3",`private` 상속에서는 기본 클래스의 public/protected 멤버가 파생 클래스 안에서 **private**로 내려옵니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-b5c6d7,"506808",cpp_09_상속,"다음 코드에서 GrandDerived 클래스의 멤버 함수 accessBase 가 컴파일 오류를 일으키는 이유는?

class Base {
protected:
    int base_val;
};

class Derived : private Base {
public:
    void test() { base_val = 10; } // 정상
};

class GrandDerived : public Derived {
public:
    void accessBase() { base_val = 20; } // 오류
};

","{""1"": ""GrandDerived 가 Derived 를 public 으로 상속했기 때문에"", ""2"": ""Derived 가 Base 를 private 으로 상속하여, base_val 이 GrandDerived 에게는 보이지 않기 때문에"", ""3"": ""base_val 이 protected 멤버이기 때문에"", ""4"": ""static 멤버가 아니기 때문에""}","2",Derived가 Base를 private 상속하면 Base의 protected 멤버(base_val)는 Derived의 private 멤버가 됩니다. 따라서 Derived를 상속받은 GrandDerived에서는 더 이상 base_val에 접근할 수 없습니다.,MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-c8d9e0,"506808",cpp_09_상속,"다음 코드의 실행 결과는? (생성자 호출 순서)

class Base { public: Base() { cout << ""B ""; } };

class Derived : public Base { public: Derived() { cout << ""D ""; } };

int main() {
    Derived d;
    return 0;
}

","{""1"": ""D B"", ""2"": ""B D"", ""3"": ""B"", ""4"": ""D""}","2",파생 객체 생성 시 **기본 클래스 생성자 → 파생 클래스 생성자** 순서로 호출됩니다. 출력은 `B D`.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-e7f8a9,"506808",cpp_09_상속,"다음 코드에서 컴파일 오류가 발생하는 이유는?

class Base {
public:
    Base(int n) {}
};

class Derived : public Base {
public:
    Derived(int n) {}
};

int main() {
    Derived d(10);
    return 0;
}

","{""1"": ""Derived 생성자가 Base 의 생성자를 명시적으로 호출하지 않았기 때문에"", ""2"": ""Base 클래스에 생성자가 전혀 정의되어 있지 않기 때문에"", ""3"": ""Derived 클래스에 기본 생성자가 없기 때문에"", ""4"": ""상속 관계에서는 매개변수 있는 생성자를 사용할 수 없기 때문에""}","1",Derived의 생성자에서 Base의 생성자를 명시적으로 호출하지 않으면 컴파일러는 Base의 기본 생성자(Base())를 자동으로 호출하려고 시도합니다. 하지만 Base 클래스에는 Base(int n)만 있고 기본 생성자가 없으므로 오류가 발생합니다.,MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-f1a2b3,"506808",cpp_09_상속,"다음 코드의 실행 결과는?

class Base {
    int val;
public:
    Base(int n) : val(n) { cout << ""B:"" << val << "" ""; }
};

class Derived : public Base {
public:
    Derived(int n) : Base(n * 2) { cout << ""D:"" << n << "" ""; }
};

int main() {
    Derived d(10);
    return 0;
}

","{""1"": ""B:10 D:10"", ""2"": ""D:10 B:10"", ""3"": ""B:20 D:10"", ""4"": ""D:10 B:20""}","3","기본 생성자가 먼저 실행되고, 인자로 `n*2`가 전달되므로 `B:20` 후에 `D:10`이 출력됩니다.",MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-a4b5c6,"506808",cpp_09_상속,Adder 와 Subtractor 두 클래스를 동시에 상속받는 Calculator 클래스를 올바르게 선언한 것은?,"{""1"": ""class Calculator : public Adder, public Subtractor {}"", ""2"": ""class Calculator : public Adder : public Subtractor {}"", ""3"": ""class Calculator extends Adder, Subtractor {}"", ""4"": ""class Calculator inherits Adder, Subtractor {}""}","1","다중 상속 표기는 `class C : public A, public B {}` 입니다. 콜론 하나에 여러 기반 클래스를 나열합니다.",MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-b7c8d9,"506808",cpp_09_상속,"다음 코드의 실행 결과는?

class Adder { public: int op(int a, int b) { return a + b; } };

class Subtractor { public: int op(int a, int b) { return a - b; } };

class Calculator : public Adder, public Subtractor {};

int main() {
    Calculator c;
    cout << c.op(10, 5);
    return 0;
}

","{""1"": ""15"", ""2"": ""5"", ""3"": ""155"", ""4"": ""컴파일 오류가 발생한다""}","4","Calculator는 Adder와 Subtractor로부터 op라는 이름의 함수를 각각 물려받습니다. c.op(10, 5) 호출 시, 컴파일러는 어떤 부모의 op 함수를 호출해야 할지 알 수 없어 모호성(ambiguity) 오류가 발생합니다.",MC,H,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-d2e3f4,"506808",cpp_09_상속,"다음 코드에 대한 설명으로 올바른 것은?

class Base {};

class L : virtual public Base {};

class R : virtual public Base {};

class Derived : public L, public R {};

int main() {
    Derived d;
    return 0;
}

","{""1"": ""Derived 객체에는 Base 클래스의 멤버가 두 번 포함된다"", ""2"": ""Derived 객체에는 Base 클래스의 멤버가 한 번만 포함된다"", ""3"": ""L 과 R 은 Base 를 상속할 수 없어 컴파일 오류가 발생한다"", ""4"": ""virtual 상속은 C++에서 지원하지 않는다""}","2","중간 클래스(L, R)가 Base를 virtual로 상속했기 때문에, 최종 파생 클래스인 Derived에는 Base의 멤버가 중복 없이 한 번만 존재하게 됩니다.",MC,M,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-e4f5a6,"506808",cpp_09_상속,"파생 클래스의 객체를 생성할 때, 기본 클래스로부터 상속되지 않는 것은?","{""1"": ""public 멤버 함수"", ""2"": ""protected 멤버 변수"", ""3"": ""생성자 및 소멸자"", ""4"": ""private 멤버 변수""}","3",생성자/소멸자는 상속되지 않습니다(파생 클래스가 자체 생성자/소멸자를 가집니다).,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-f6a7b8,"506808",cpp_09_상속,"다음 코드에서 cp.showPoint()가 정상적으로 호출될 수 있는 이유는?

class Point {
public:
    void showPoint();
};

class ColorPoint : public Point {
public:
    void showColorPoint() {
        showPoint();
    }
};
","{""1"": ""showPoint 가 ColorPoint 의 friend 함수이기 때문에"", ""2"": ""showPoint 가 public 멤버이므로 파생 클래스에서 접근 가능하기 때문에"", ""3"": ""showPoint 가 static 멤버 함수이기 때문에"", ""4"": ""showPoint 가 protected 멤버이기 때문에""}","2",기본 클래스의 **public 멤버**는 파생 클래스에서 그대로 접근 가능합니다.,MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-a8b9c0,"506808",cpp_09_상속,"다음 코드의 실행 결과는?

class TV {
public:
    int size;
    TV(int s) : size(s) {}
};

class WideTV : public TV {
public:
    WideTV(int s) : TV(s) {}
};

class SmartTV : public WideTV {
public:
    SmartTV(int s) : WideTV(s) {}
};

int main() {
    SmartTV htv(55);
    cout << htv.size;
    return 0;
}

","{""1"": ""0"", ""2"": ""55"", ""3"": ""알 수 없는 값"", ""4"": ""컴파일 오류가 발생한다""}","2","`size`는 `TV`의 public 멤버이며, 생성자 인자 55가 전달되어 최종적으로 55가 출력됩니다.",MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-b1c2d3,"506808",cpp_09_상속,"다음 코드의 실행 결과는?

class A { public: A() { cout << “A “; } };

class B { public: B() { cout << “B “; } };

class C : public A, public B { public: C() { cout << “C “; } };

int main() {
C c;
return 0;
}

","{""1"": ""A B C"", ""2"": ""B A C"", ""3"": ""C A B"", ""4"": ""A C B""}","1","다중 상속의 생성자 호출 순서는 상속 목록 순서(A, B) 이후 파생(C)입니다. 그래서 `A B C`가 출력됩니다.",MC,E,cpp_09_상속_quiz_sol.pdf,MANU,adm,2025-09-29 17:43:47.443,,,N
ITEM-506808-A1B2C3,"506808",cpp_10_가상함수와추상클래스,"파생 클래스에서 기본 클래스의 함수와 완전히 동일한 원형으로 함수를 다시 만드는 것을
무엇이라고 하는가?","{
  ""1"": ""함수 중복 (Overloading)"",
  ""2"": ""함수 재정의 (Redefinition)"",
  ""3"": ""함수 선언 (Declaration)"",
  ""4"": ""함수 호출 (Call)""
}","2",오버라이딩은 기본 클래스와 동일한 함수 원형을 파생 클래스에서 다시 정의하는 것을 말합니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-D4E5F6,"506808",cpp_10_가상함수와추상클래스,"다음 코드에서 pBase->f(); 호출 시 Base::f()가 실행되는 이유는?

class Base {
public:
    void f() { cout << ""Base""; }
};

class Derived : public Base {
public:
    void f() { cout << ""Derived""; }
};

int main() {
    Derived d;
    Base* pBase = &d;
    pBase->f();
    return 0;
}

","{
  ""1"": ""포인터 pBase 의 타입이 Base*이므로 컴파일 시점에 Base::f() 호출이 결정되기 때문에"",
  ""2"": ""Derived 클래스의 f() 함수가 private 멤버이기 때문에"",
  ""3"": ""pBase 가 가리키는 실제 객체가 Base 타입이기 때문에"",
  ""4"": ""항상 기본 클래스의 함수가 우선적으로 호출되기 때문에""
}","1","f() 함수가 virtual이 아니므로, 호출할 함수는 포인터의 타입(Base*)에 따라 컴파일 시간에 결정됩니다. 이를 정적 바인딩이라고 합니다.",MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-G7H8J9,"506808",cpp_10_가상함수와추상클래스,"다음 코드에서 show 함수를 가상 함수로 선언하려 한다. 빈칸에 들어갈 키워드는?

class Base {
public:
_____ void show();
};

","{
  ""1"": ""static"",
  ""2"": ""virtual"",
  ""3"": ""override"",
  ""4"": ""friend""
}","2",가상 함수는 함수 선언 앞에 virtual 키워드를 붙여 선언합니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-K1L2M3,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Base {
public:
    virtual void f() { cout << ""Base""; }
};

class Derived : public Base {
public:
    void f() override { cout << ""Derived""; }
};

int main() {
    Derived d;
    Base* pBase = &d;
    pBase->f();
    return 0;
}

","{
  ""1"": ""Base"",
  ""2"": ""Derived"",
  ""3"": ""BaseDerived"",
  ""4"": ""컴파일 오류가 발생한다""
}","2","f()가 가상 함수이므로, pBase가 가리키는 실제 객체(Derived)의 f() 함수가 실행 시간에 호출됩니다(동적 바인딩).",MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-N4P5Q6,"506808",cpp_10_가상함수와추상클래스,"기본 클래스의 포인터로 파생 클래스 객체를 가리킬 때, virtual 함수 호출은 포인터의 타입을
따르는가, 아니면 포인터가 실제 가리키는 객체의 타입을 따르는가?","{
  ""1"": ""항상 포인터의 타입을 따른다 (정적 바인딩)"",
  ""2"": ""항상 포인터가 실제 가리키는 객체의 타입을 따른다 (동적 바인딩)"",
  ""3"": ""private 멤버일 경우에만 객체의 타입을 따른다"",
  ""4"": ""const 함수일 경우에만 포인터의 타입을 따른다""
}","2",가상 함수는 런타임에 실제 객체 타입을 기준으로 결정(동적 바인딩)됩니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-R7S8T9,"506808",cpp_10_가상함수와추상클래스,"다음 코드에서 pShape->paint();가 Circle::draw()를 호출하는 이유는?

class Shape {
public:
    void paint() { draw(); }
    virtual void draw() { cout << ""Shape""; }
};

class Circle : public Shape {
public:
    void draw() override { cout << ""Circle""; }
};

int main() {
    Shape* pShape = new Circle();
    pShape->paint();
    delete pShape;
    return 0;
}

","{
  ""1"": ""paint 함수가 virtual 이기 때문에"",
  ""2"": ""paint 함수 내부에서 호출된 draw 함수가 virtual 이며, 동적 바인딩에 의해 실제 객체인 Circle 의 draw 가 실행되기 때문에"",
  ""3"": ""Shape 의 draw 함수가 private 멤버이기 때문에"",
  ""4"": ""Circle 클래스가 Shape 보다 메모리상에서 앞에 있기 때문에""
}","2","paint() 함수 내부에서 호출된 draw 함수가 virtual이며, 동적 바인딩에 의해 실제 객체인 Circle의 draw가 실행되기 때문입니다.",MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-U1V2W3,"506808",cpp_10_가상함수와추상클래스,"파생 클래스에서 함수를 오버라이딩(overriding)할 때, 기본 클래스의 함수와 반드시 일치해야
하는 것이 아닌 것은?","{
  ""1"": ""함수 이름"",
  ""2"": ""매개변수 목록"",
  ""3"": ""리턴 타입"",
  ""4"": ""virtual 키워드의 유무""
}","4",파생 클래스에서는 virtual 키워드를 생략할 수 있습니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-X4Y5Z6,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Base {
public:
    virtual void f() { cout << ""B""; }
};

class Derived : public Base {
public:
    void f() override { cout << ""D""; }
};

class GrandDerived : public Derived {
public:
    void f() override { cout << ""G""; }
};

int main() {
    GrandDerived g;
    Base* bp = &g;
    Derived* dp = &g;
    bp->f();
    dp->f();
    return 0;
}

","{
  ""1"": ""B D"",
  ""2"": ""D G"",
  ""3"": ""G G"",
  ""4"": ""B G""
}","3","f()는 가상 함수이므로, bp와 dp 모두 실제 객체인 GrandDerived의 f() 함수를 호출합니다.",MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-A7B8C9,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Shape {
public:
    virtual void draw() { cout << ""Shape""; }
};

class Circle : public Shape {
public:
    void draw() override {
        Shape::draw();
        cout << ""-Circle"";
    }
};

int main() {
    Shape* p = new Circle();
    p->draw();
    delete p;
    return 0;
}

","{
  ""1"": ""Circle"",
  ""2"": ""Shape"",
  ""3"": ""Shape-Circle"",
  ""4"": ""Circle-Shape""
}","3","p->draw()는 동적 바인딩에 의해 Circle::draw()를 호출합니다. Circle::draw() 내부에서 Shape::draw()를 명시적으로 먼저 호출하므로 ""Shape""가 출력되고, 이후 ""-Circle""이 출력됩니다.",MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-D0E1F2,"506808",cpp_10_가상함수와추상클래스,기본 클래스의 소멸자를 virtual 로 선언해야 하는 가장 중요한 이유는?,"{
  ""1"": ""소멸자의 실행 속도를 높이기 위해"",
  ""2"": ""기본 클래스의 포인터로 파생 클래스 객체를 delete 할 때, 파생 클래스의 소멸자가 호출되도록 하기 위해"",
  ""3"": ""모든 클래스는 반드시 가상 소멸자를 가져야 하기 때문에"",
  ""4"": ""소멸자가 오버로딩될 수 있도록 하기 위해""
}","2","기본 클래스의 소멸자가 virtual이 아니면, 기본 클래스 포인터로 delete 시 파생 클래스의 소멸자가 호출되지 않아 메모리 누수가 발생할 수 있습니다.",MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-G3H4J5,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Base {
public:
    ~Base() { cout << ""B""; }
};

class Derived : public Base {
public:
    ~Derived() { cout << ""D""; }
};

int main() {
    Base* p = new Derived();
    delete p;
    return 0;
}

","{
  ""1"": ""D B"",
  ""2"": ""B D"",
  ""3"": ""B"",
  ""4"": ""D""
}","3","Base 클래스의 소멸자에 virtual 키워드가 없으므로, 정적 바인딩에 의해 포인터 타입(Base*)의 소멸자만 호출됩니다.",MC,H,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-K6L7M8,"506808",cpp_10_가상함수와추상클래스,다음 중 순수 가상 함수를 올바르게 선언한 것은?,"{
  ""1"": ""virtual void func() {};"",
  ""2"": ""virtual void func() = 0;"",
  ""3"": ""virtual void func() = null;"",
  ""4"": ""pure virtual void func();""
}","2",순수 가상 함수는 “= 0”으로 선언합니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-N9P0Q1,"506808",cpp_10_가상함수와추상클래스,순수 가상 함수를 하나 이상 포함하는 클래스를 무엇이라고 하는가?,"{
  ""1"": ""기본 클래스 (Base Class)"",
  ""2"": ""추상 클래스 (Abstract Class)"",
  ""3"": ""파생 클래스 (Derived Class)"",
  ""4"": ""템플릿 클래스 (Template Class)""
}","2",순수 가상 함수를 하나 이상 가지는 클래스는 추상 클래스입니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-R2S3T4,"506808",cpp_10_가상함수와추상클래스,추상 클래스에 대한 설명으로 틀린 것은?,"{
  ""1"": ""객체를 직접 생성할 수 없다"",
  ""2"": ""추상 클래스는 하나 이상의 순수 가상 함수를 포함해야 한다"",
  ""3"": ""추상 클래스 타입의 포인터 변수는 선언할 수 있다"",
  ""4"": ""모든 멤버 함수가 순수 가상 함수여야 한다""
}","4",모든 멤버 함수가 순수 가상일 필요는 없습니다(일반 멤버 함수 포함 가능).,MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-U5V6W7,"506808",cpp_10_가상함수와추상클래스,"다음 코드에서 가장 먼저 컴파일 오류가 발생하는 라인은?

class AbstractCalc {
public:
    virtual int calc(int a, int b) = 0;
};

int main() {
    AbstractCalc obj;
    int n = obj.calc(1, 2);
    return 0;
}

","{
  ""1"": ""virtual int calc(int a, int b) = 0;"",
  ""2"": ""AbstractCalc obj;"",
  ""3"": ""int n = obj.calc(1, 2);"",
  ""4"": ""오류가 발생하지 않는다""
}","2",추상 클래스는 미완성된 클래스로 간주되어 객체(인스턴스)를 직접 생성할 수 없습니다.,MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-X8Y9Z0,"506808",cpp_10_가상함수와추상클래스,추상 클래스를 상속받은 파생 클래스가 추상 클래스가 아니기 위한 조건은?,"{
  ""1"": ""파생 클래스의 생성자를 반드시 구현해야 한다"",
  ""2"": ""기본 클래스의 모든 멤버 변수를 public 으로 만들어야 한다"",
  ""3"": ""기본 클래스로부터 물려받은 모든 순수 가상 함수를 오버라이딩하여 구현해야 한다"",
  ""4"": ""파생 클래스에는 가상 함수가 없어야 한다""
}","3",상속받은 모든 순수 가상 함수를 구현해야 파생 클래스가 구체 클래스가 됩니다.,MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-A2B3C4,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Calculator {
public:
    virtual int calc(int a, int b) = 0;
};

class Adder : public Calculator {
public:
    int calc(int a, int b) override { return a + b; }
};

int main() {
    Calculator* p = new Adder();
    cout << p->calc(10, 20);
    delete p;
    return 0;
}

","{
  ""1"": ""0"",
  ""2"": ""10"",
  ""3"": ""20"",
  ""4"": ""30""
}","4",Adder::calc이 10+20을 반환하므로 30이 출력됩니다.,MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-D5E6F7,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class Base {
public:
    virtual ~Base() { cout << ""B""; }
};

class Derived : public Base {
public:
    ~Derived() { cout << ""D""; }
};

int main() {
    Base* p = new Derived();
    delete p;
    return 0;
}

","{
  ""1"": ""D B"",
  ""2"": ""B D"",
  ""3"": ""B"",
  ""4"": ""D""
}","1","Base의 소멸자가 virtual이므로, delete p 시 동적 바인딩이 발생합니다. 실제 객체인 Derived의 소멸자(~Derived())가 먼저 호출되고, 그 다음에 기본 클래스인 Base의 소멸자(~Base())가 호출됩니다.",MC,M,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-G8H9J0,"506808",cpp_10_가상함수와추상클래스,override 키워드를 사용하는 주된 이점은?,"{
  ""1"": ""함수를 무조건 오버라이딩하도록 강제한다"",
  ""2"": ""기본 클래스에 해당 가상 함수가 없거나, 함수 원형이 다르면 컴파일 오류를 발생시켜 실수를 방지한다"",
  ""3"": ""함수의 실행 속도를 빠르게 한다"",
  ""4"": ""함수를 자동으로 inline 처리한다""
}","2","override 키워드는 개발자의 오버라이딩 의도를 컴파일러에게 명확히 알려, 의도와 다른 함수 재정의가 되는 것을 막아줍니다.",MC,E,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-K9L0M1,"506808",cpp_10_가상함수와추상클래스,"다음 코드의 실행 결과는?

class A {
public:
    virtual void func() { cout << ""A""; }
};

class B : public A {
public:
    void func() override final { cout << ""B""; }
};

class C : public B {
public:
    void func() override { cout << ""C""; }
};

","{
  ""1"": ""A"",
  ""2"": ""B"",
  ""3"": ""C"",
  ""4"": ""컴파일 오류가 발생한다""
}","4","B 클래스의 func 함수가 final로 선언되었기 때문에, B를 상속받는 C 클래스에서는 더 이상 func 함수를 오버라이딩할 수 없습니다.",MC,H,cpp_10_가상함수와추상클래스_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:06.145,,,N
ITEM-506808-A3F9QX,"506808",cpp_11_템플릿과STL,"함수 중복의 코드 중복 문제를 해결하기 위해, 데이터 타입에 상관없이 동작하는 함수를 만드는 C++ 도구는?","{
  ""1"": ""friend 함수"",
  ""2"": ""virtual 함수"",
  ""3"": ""템플릿 (template)"",
  ""4"": ""static 함수""
}","3",여러 타입에 대해 같은 로직을 재사용하려면 함수/클래스 템플릿을 사용합니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-B6N2VD,"506808",cpp_11_템플릿과STL,다음 함수 템플릿 선언 중 문법적으로 올바른 것은?,"{
  ""1"": ""template <T> void print(T a);"",
  ""2"": ""template <typename T> void print(T a);"",
  ""3"": ""template void print<typename T>(T a);"",
  ""4"": ""class<T> void print(T a);""
}","2",템플릿 매개변수는 반드시 `template <typename T>` 또는 `template <class T>` 형식입니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-C8Z7ME,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

template <typename T>
void myswap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

int main() {
	int x = 10, y = 20;
	myswap(x, y);
	cout << x;
	return 0;
}

","{
  ""1"": ""10"",
  ""2"": ""20"",
  ""3"": ""30"",
  ""4"": ""컴파일 오류가 발생한다""
}","2",`myswap` 호출 후 x↔y가 바뀌므로 `x`는 20이 출력됩니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-D2K4PJ,"506808",cpp_11_템플릿과STL,"다음 코드에서 컴파일 오류가 발생하는 이유는?

template <typename T>
void print(T a, T b) {
	cout << a << b;
}

int main() {
	print(10, 20.5);
	return 0;
}

","{
  ""1"": ""print 함수가 private 이기 때문에"",
  ""2"": ""main 함수에서 템플릿 함수를 호출할 수 없기 때문에"",
  ""3"": ""템플릿 인자 T 가 int 와 double 로 서로 다르게 추론되어 모호하기 때문에"",
  ""4"": ""템플릿 함수는 매개변수를 하나만 가질 수 있기 때문에""
}","3",하나의 T로 두 인자를 추론해야 하는데 int와 double이 섞여 모호성이 생깁니다.,MC,M,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-E5S1RT,"506808",cpp_11_템플릿과STL,"다음 코드와 같이 타입이 다른 인자를 함수 템플릿에 전달할 때, 오류를 해결하기 위한 올바른 호출 방법은?

template <typename T>
T add(T a, T b) { return a + b; }

int main() {
	int a = 10;
	double b = 3.14;
	add(a, b);  오류 발생
}

","{
  ""1"": ""add( (float)a, b )"",
  ""2"": ""add<double>(a, b)"",
  ""3"": ""add( a, (int)b )"",
  ""4"": ""add<int, double>(a, b)""
}","2","함수 이름 뒤에 꺾쇠 괄호 <>를 사용하여 템플릿의 타입을 double로 명시적으로 지정하면, int 타입인 a가 double로 변환되어 함수가 정상적으로 호출됩니다.",MC,M,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-F9H3YA,"506808",cpp_11_템플릿과STL,"const char* 타입에 대해서는 strcmp 를 사용하도록 smaller 함수 템플릿을 특수화하는
올바른 코드는?","{
  ""1"": ""template<> const char* smaller<const char*>(...);"",
  ""2"": ""template<const char*> const char* smaller(...);"",
  ""3"": ""special<const char*> const char* smaller(...);"",
  ""4"": ""template<T=const char*> T smaller(...);""
}","1",명시적 특수화는 `template<> 반환형 함수명<특수화타입>(...)` 형태로 작성합니다.,MC,H,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-G7M8LU,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

template <typename T, int size>
	T sumArray(T data[]) {
	T sum = 0;
	for (int i = 0; i < size; i++) sum += data[i];
return sum;
}

int main() {
	int arr[] = {1, 2, 3, 4, 5};
	cout << sumArray<int, 5>(arr);
	return 0;
}

","{
  ""1"": ""0"",
  ""2"": ""5"",
  ""3"": ""15"",
  ""4"": ""컴파일 오류가 발생한다""
}","3","1~5의 합은 15입니다. 비타입 템플릿 인자 `size=5`를 사용했습니다.",MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-H1P5CS,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

template <typename T>
void print(T data) { cout << ""Template ""; }

void print(int data) { cout << ""Integer ""; }

int main() {
	print(10);
	print(3.14);
	print('a');
	return 0;
}

","{
  ""1"": ""Template Template Template"",
  ""2"": ""Integer Template Template"",
  ""3"": ""Integer Integer Integer"",
  ""4"": ""컴파일 오류가 발생한다""
}","2","print(10)은 인자가 int이므로 일반 함수인 void print(int)가 호출됩니다. 3.14와 a는 int 타입이 아니므로, 함수 템플릿으로부터 구체화된 함수들이 호출됩니다.",MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-J4X9NB,"506808",cpp_11_템플릿과STL,int 타입의 데이터를 저장하는 Stack 클래스 템플릿의 객체를 생성하는 올바른 코드는?,"{
  ""1"": ""Stack s<int>;"",
  ""2"": ""Stack s(int);"",
  ""3"": ""Stack<int> s;"",
  ""4"": ""int<Stack> s;""
}","3",클래스 템플릿 인자를 꺾쇠로 지정하고 객체 이름을 뒤에 둡니다: `Stack<int> s;`,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-K6C2WD,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

template <typename T>
class Stack {
	T data[10];
	int top = -1;
public:
	void push(T val) { data[++top] = val; }
	T pop() { return data[top--]; }
};

int main() {
	Stack<int> s;
	s.push(10);
	s.push(20);
	cout << s.pop();
	return 0;
}
","{
  ""1"": ""10"",
  ""2"": ""20"",
  ""3"": ""30"",
  ""4"": ""컴파일 오류가 발생한다""
}","2",스택은 LIFO이므로 마지막에 넣은 20이 먼저 나옵니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-L8R1QK,"506808",cpp_11_템플릿과STL,"다음 GClass 템플릿 클래스를 올바르게 구체화한 코드는?

template <typename T1, typename T2>
class GClass {
	T1 data1;
	T2 data2;
public:
	GClass(T1 a, T2 b) : data1(a), data2(b) {}
};

","{
  ""1"": ""GClass<int, double> g(10, 3.14);"",
  ""2"": ""GClass<int> g(10, 3.14);"",
  ""3"": ""GClass g<int, double>(10, 3.14);"",
  ""4"": ""GClass g(10, 3.14);""
}","1","두 타입 매개변수(T1, T2)를 모두 명시해야 합니다.",MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-M3V7ZE,"506808",cpp_11_템플릿과STL,"다음 코드에서 컴파일 오류가 발생하는 라인은?

template <typename T, int size = 10>
class Array {
	T data[size];
};

int main() {
	Array<int, 5> a1;
	Array<int> a2;
	Array<5> a3;
	return 0;
}

","{
  ""1"": ""Array<int, 5> a1;"",
  ""2"": ""Array<int> a2;"",
  ""3"": ""Array<5> a3;"",
  ""4"": ""오류가 발생하지 않는다""
}","3",템플릿의 첫 번째 매개변수는 타입이어야 하는데 5는 타입이 아니므로 컴파일 오류가 발생합니다.,MC,H,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-N9G4TP,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

template <typename T>
class Counter {
public:
	static int count;
	Counter() { count++; }
};

template<typename T>
int Counter<T>::count = 0;

int main() {
	Counter<int> c1;
	Counter<int> c2;
	Counter<double> c3;
	cout << Counter<int>::count << Counter<double>::count;
	return 0;
}

","{
  ""1"": ""31"",
  ""2"": ""21"",
  ""3"": ""12"",
  ""4"": ""33""
}","2","static 멤버 변수는 템플릿이 구체화될 때 타입별로 별도로 생성됩니다. 따라서 Counter<int> 객체가 두 번 생성되어 Counter<int>::count는 2가 되고, Counter<double> 객체가 한 번 생성되어 Counter<double>::count는 1이 됩니다.",MC,M,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-P2J6HY,"506808",cpp_11_템플릿과STL,C++ STL 을 구성하는 세 가지 주요 요소가 아닌 것은?,"{
  ""1"": ""컨테이너 (Container)"",
  ""2"": ""반복자 (Iterator)"",
  ""3"": ""알고리즘 (Algorithm)"",
  ""4"": ""포인터 (Pointer)""
}","4",STL의 3요소는 컨테이너/반복자/알고리즘이며 포인터는 포함되지 않습니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-Q6L5AS,"506808",cpp_11_템플릿과STL,가변 크기 배열을 일반화한 STL 컨테이너는?,"{
  ""1"": ""map"",
  ""2"": ""set"",
  ""3"": ""vector"",
  ""4"": ""stack""
}","3",`vector`는 크기 변경이 쉬운 동적 배열 컨테이너입니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-R1T8WU,"506808",cpp_11_템플릿과STL,"다음 코드의 실행 결과는?

#include <vector>
#include <iostream>

int main() {
    vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v[0] = 30;
    cout << v.at(0) << v.at(1);
    return 0;
}
","{
    ""1"": ""1020"",
    ""2"": ""3010"",
    ""3"": ""3020"",
    ""4"": ""컴파일 오류가 발생한다""
  }","3","v[0]=30 이후 at(0)=30, at(1)=20 이므로 “3020”이 출력됩니다.",MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-S9C3BM,"506808",cpp_11_템플릿과STL,STL 알고리즘 함수 sort 를 사용하기 위해 포함해야 하는 헤더 파일은?,"{
  ""1"": ""<vector>"",
  ""2"": ""<iterator>"",
  ""3"": ""<algorithm>"",
  ""4"": ""<sort>""
}","3",정렬 알고리즘은 `<algorithm>` 헤더에 정의되어 있습니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-T7F2KQ,"506808",cpp_11_템플릿과STL,"for_each(v.begin(), v.end(), func); 코드에 대한 설명으로 올바른 것은?","{
  ""1"": ""v 의 모든 원소에 대해 func 함수를 한 번만 호출한다"",
  ""2"": ""v 의 시작부터 끝까지 각 원소를 func 함수의 인자로 전달하며 호출한다"",
  ""3"": ""v 의 원소를 func 함수의 결과로 모두 바꾼다"",
  ""4"": ""v 의 원소 개수만큼 func 함수를 선언한다""
}","2",for_each는 주어진 범위(시작 반복자부터 끝 반복자 바로 앞까지)의 모든 원소에 대해 지정된 함수를 한 번씩 적용하는 알고리즘입니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-U4A9DG,"506808",cpp_11_템플릿과STL,다음 중 람다(lambda)식의 캡쳐 리스트에 대한 설명으로 올바른 것은?,"{
  ""1"": ""람다식이 반환하는 값의 타입을 지정한다"",
  ""2"": ""람다식이 받는 매개변수의 목록을 정의한다"",
  ""3"": ""람다식 외부의 변수를 람다식 내부에서 사용할 수 있도록 전달하는 역할을 한다"",
  ""4"": ""람다식의 실행 코드를 작성하는 부분이다""
}","3",캡쳐 리스트 []는 람다식이 정의된 범위의 지역 변수들을 람다식 내부에서 사용할 수 있게 해주는 기능입니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
ITEM-506808-V5E6RH,"506808",cpp_11_템플릿과STL,두 정수를 매개변수로 받아 그 합을 정수로 반환하는 람다식을 올바르게 작성한 것은?,"{
  ""1"": ""(int a, int b) -> int { return a + b; };"",
  ""2"": ""[=](int a, int b) { return a + b; };"",
  ""3"": ""[](int a, int b) -> int { return a + b; };"",
  ""4"": ""[](int a, int b) : int { return a + b; };""
}","3",람다의 반환 타입 지정은 `-> int` 문법을 사용합니다.,MC,E,cpp_11_템플릿과STL_quiz_sol.pdf,MANU,adm,2025-09-29 17:44:22.752,,,N
